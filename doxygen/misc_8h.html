<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RaiBlocks: cryptopp/misc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RaiBlocks
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_9add1f8e99c4bd518e48f88b3c5a17b7.html">cryptopp</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">misc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Utility functions for the Crypto++ library.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;config.h&quot;</code><br />
<code>#include &quot;<a class="el" href="cryptlib_8h_source.html">cryptlib.h</a>&quot;</code><br />
<code>#include &quot;stdcpp.h&quot;</code><br />
<code>#include &quot;<a class="el" href="smartptr_8h_source.html">smartptr.h</a>&quot;</code><br />
</div>
<p><a href="misc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_compile_assert.html">CompileAssert&lt; b &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_empty.html">Empty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="class_empty.html" title="An Empty class. ">Empty</a> class.  <a href="class_empty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_two_bases.html">TwoBases&lt; BASE1, BASE2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_three_bases.html">ThreeBases&lt; BASE1, BASE2, BASE3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_holder.html">ObjectHolder&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses encapsulation to hide an object in derived classes.  <a href="class_object_holder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_not_copyable.html">NotCopyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures an object is not copyable.  <a href="class_not_copyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_new_object.html">NewObject&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object factory function.  <a href="struct_new_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_singleton.html">Singleton&lt; T, F, instance &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts the instantiation of a class to one static object without locks.  <a href="class_singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_get_block.html">GetBlock&lt; T, B, A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a block of memory.  <a href="class_get_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_put_block.html">PutBlock&lt; T, B, A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a block of memory.  <a href="class_put_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_block_get_and_put.html">BlockGetAndPut&lt; T, B, GA, PA &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a block of memory.  <a href="struct_block_get_and_put.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_safe_shifter.html">SafeShifter&lt; overflow &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely shift values when undefined behavior could occur.  <a href="struct_safe_shifter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_safe_shifter_3_01true_01_4.html">SafeShifter&lt; true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts a value in the presence of overflow.  <a href="struct_safe_shifter_3_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_safe_shifter_3_01false_01_4.html">SafeShifter&lt; false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts a value in the absence of overflow.  <a href="struct_safe_shifter_3_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9c7136e2091dd0e0fb5d4e97010b8430"><td class="memItemLeft" align="right" valign="top"><a id="a9c7136e2091dd0e0fb5d4e97010b8430"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_FAST_ROTATE</b>(x)&#160;&#160;&#160;0</td></tr>
<tr class="separator:a9c7136e2091dd0e0fb5d4e97010b8430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c75bb398badb69c7577b21486f9963f"><td class="memItemLeft" align="right" valign="top"><a id="a3c75bb398badb69c7577b21486f9963f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SIZE_MAX</b>&#160;&#160;&#160;((std::numeric_limits&lt;size_t&gt;::max)())</td></tr>
<tr class="separator:a3c75bb398badb69c7577b21486f9963f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07644575199e2dc5fa4eac13c3dea2e"><td class="memItemLeft" align="right" valign="top"><a id="ab07644575199e2dc5fa4eac13c3dea2e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_COMPILE_ASSERT</b>(assertion)&#160;&#160;&#160;CRYPTOPP_COMPILE_ASSERT_INSTANCE(assertion, __LINE__)</td></tr>
<tr class="separator:ab07644575199e2dc5fa4eac13c3dea2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4002b9b8cfe3baff72fc606a0525c2fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_COMPILE_ASSERT_INSTANCE</b>(assertion,  instance)</td></tr>
<tr class="separator:a4002b9b8cfe3baff72fc606a0525c2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687aa2e764e0e2f1f4649e68d9869a3b"><td class="memItemLeft" align="right" valign="top"><a id="a687aa2e764e0e2f1f4649e68d9869a3b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_ASSERT_JOIN</b>(X,  Y)&#160;&#160;&#160;CRYPTOPP_DO_ASSERT_JOIN(X, Y)</td></tr>
<tr class="separator:a687aa2e764e0e2f1f4649e68d9869a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3676a29b97ad67ab9efc2682ef78d4"><td class="memItemLeft" align="right" valign="top"><a id="aed3676a29b97ad67ab9efc2682ef78d4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_DO_ASSERT_JOIN</b>(X,  Y)&#160;&#160;&#160;X##Y</td></tr>
<tr class="separator:aed3676a29b97ad67ab9efc2682ef78d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2b6e8b1b96a4ed267a8cec32a92425"><td class="memItemLeft" align="right" valign="top"><a id="acc2b6e8b1b96a4ed267a8cec32a92425"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>COUNTOF</b>(x)&#160;&#160;&#160;(sizeof(x)/sizeof(x[0]))</td></tr>
<tr class="separator:acc2b6e8b1b96a4ed267a8cec32a92425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d4cbe1e093c683432a147eb1ccb293"><td class="memItemLeft" align="right" valign="top"><a id="a56d4cbe1e093c683432a147eb1ccb293"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEMORY_BARRIER</b>()</td></tr>
<tr class="separator:a56d4cbe1e093c683432a147eb1ccb293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff336cfe214604ffdd1075d94a11f8c5"><td class="memItemLeft" align="right" valign="top"><a id="aff336cfe214604ffdd1075d94a11f8c5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RETURN_IF_NONZERO</b>(x)&#160;&#160;&#160;size_t returnedValue = x; if (returnedValue) return returnedValue</td></tr>
<tr class="separator:aff336cfe214604ffdd1075d94a11f8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5d495902796a542084124233281265"><td class="memItemLeft" align="right" valign="top"><a id="afb5d495902796a542084124233281265"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GETBYTE</b>(x,  y)&#160;&#160;&#160;(unsigned int)byte((x)&gt;&gt;(8*(y)))</td></tr>
<tr class="separator:afb5d495902796a542084124233281265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb110e20bd83872104cf1b5a0d19ff1e"><td class="memItemLeft" align="right" valign="top"><a id="afb110e20bd83872104cf1b5a0d19ff1e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_GET_BYTE_AS_BYTE</b>(x,  y)&#160;&#160;&#160;byte((x)&gt;&gt;(8*(y)))</td></tr>
<tr class="separator:afb110e20bd83872104cf1b5a0d19ff1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44245f76e0fc08ab8ba76771ef3d9f5"><td class="memItemLeft" align="right" valign="top"><a id="ab44245f76e0fc08ab8ba76771ef3d9f5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_BLOCK_1</b>(n,  t,  s)&#160;&#160;&#160;t* m_##n() {return (t *)(void *)(m_aggregate+0);}     size_t SS1() {return       sizeof(t)*(s);} size_t m_##n##Size() {return (s);}</td></tr>
<tr class="separator:ab44245f76e0fc08ab8ba76771ef3d9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca956e0abd7368e25cebeb9513616eca"><td class="memItemLeft" align="right" valign="top"><a id="aca956e0abd7368e25cebeb9513616eca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_BLOCK_2</b>(n,  t,  s)&#160;&#160;&#160;t* m_##n() {return (t *)(void *)(m_aggregate+SS1());} size_t SS2() {return SS1()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}</td></tr>
<tr class="separator:aca956e0abd7368e25cebeb9513616eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a4e24d34c37d65a379bd06a4bf12d2"><td class="memItemLeft" align="right" valign="top"><a id="a48a4e24d34c37d65a379bd06a4bf12d2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_BLOCK_3</b>(n,  t,  s)&#160;&#160;&#160;t* m_##n() {return (t *)(void *)(m_aggregate+SS2());} size_t SS3() {return SS2()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}</td></tr>
<tr class="separator:a48a4e24d34c37d65a379bd06a4bf12d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8366a854dd78fbaba4da6ace69b3b4"><td class="memItemLeft" align="right" valign="top"><a id="a5e8366a854dd78fbaba4da6ace69b3b4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_BLOCK_4</b>(n,  t,  s)&#160;&#160;&#160;t* m_##n() {return (t *)(void *)(m_aggregate+SS3());} size_t SS4() {return SS3()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}</td></tr>
<tr class="separator:a5e8366a854dd78fbaba4da6ace69b3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d00455e80e440dde3572996227bf0f0"><td class="memItemLeft" align="right" valign="top"><a id="a3d00455e80e440dde3572996227bf0f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_BLOCK_5</b>(n,  t,  s)&#160;&#160;&#160;t* m_##n() {return (t *)(void *)(m_aggregate+SS4());} size_t SS5() {return SS4()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}</td></tr>
<tr class="separator:a3d00455e80e440dde3572996227bf0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11940604e7e44c16170ab0bc89e4e8f6"><td class="memItemLeft" align="right" valign="top"><a id="a11940604e7e44c16170ab0bc89e4e8f6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_BLOCK_6</b>(n,  t,  s)&#160;&#160;&#160;t* m_##n() {return (t *)(void *)(m_aggregate+SS5());} size_t SS6() {return SS5()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}</td></tr>
<tr class="separator:a11940604e7e44c16170ab0bc89e4e8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fee2fd43faebed6eac61f1f3d8bc423"><td class="memItemLeft" align="right" valign="top"><a id="a4fee2fd43faebed6eac61f1f3d8bc423"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_BLOCK_7</b>(n,  t,  s)&#160;&#160;&#160;t* m_##n() {return (t *)(void *)(m_aggregate+SS6());} size_t SS7() {return SS6()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}</td></tr>
<tr class="separator:a4fee2fd43faebed6eac61f1f3d8bc423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac56e108366ccfa9c5ecf923b52e936"><td class="memItemLeft" align="right" valign="top"><a id="a4ac56e108366ccfa9c5ecf923b52e936"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_BLOCK_8</b>(n,  t,  s)&#160;&#160;&#160;t* m_##n() {return (t *)(void *)(m_aggregate+SS7());} size_t SS8() {return SS7()+sizeof(t)*(s);} size_t m_##n##Size() {return (s);}</td></tr>
<tr class="separator:a4ac56e108366ccfa9c5ecf923b52e936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade27627ae9dfbc2bee30153a513e229c"><td class="memItemLeft" align="right" valign="top"><a id="ade27627ae9dfbc2bee30153a513e229c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRYPTOPP_BLOCKS_END</b>(i)&#160;&#160;&#160;size_t SST() {return SS##i();} void AllocateBlocks() {m_aggregate.New(SST());} <a class="el" href="class_sec_block.html">AlignedSecByteBlock</a> m_aggregate;</td></tr>
<tr class="separator:ade27627ae9dfbc2bee30153a513e229c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a108a15557c06bfa449e87879f283a268"><td class="memItemLeft" align="right" valign="top"><a id="a108a15557c06bfa449e87879f283a268"></a>
typedef <a class="el" href="cryptlib_8h.html#ad00625e1e5e96656feaf83fd53c1ab4e">LittleEndian</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NativeByteOrder</b></td></tr>
<tr class="separator:a108a15557c06bfa449e87879f283a268"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2fd1731195384cbf23176e1e9872fe03"><td class="memTemplParams" colspan="2"><a id="a2fd1731195384cbf23176e1e9872fe03"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2fd1731195384cbf23176e1e9872fe03"><td class="memTemplItemLeft" align="right" valign="top">ANONYMOUS_NAMESPACE_BEGIN T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>NumericLimitsMin</b> ()</td></tr>
<tr class="separator:a2fd1731195384cbf23176e1e9872fe03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39f468338a6ad6a22fa0e9c16819fa7"><td class="memTemplParams" colspan="2"><a id="af39f468338a6ad6a22fa0e9c16819fa7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af39f468338a6ad6a22fa0e9c16819fa7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>NumericLimitsMax</b> ()</td></tr>
<tr class="separator:af39f468338a6ad6a22fa0e9c16819fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6fcbaaf6f72fe46a6d911b033dfea0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0">memcpy_s</a> (void *dest, size_t sizeInBytes, const void *src, size_t count)</td></tr>
<tr class="memdesc:a5f6fcbaaf6f72fe46a6d911b033dfea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounds checking replacement for memcpy()  <a href="#a5f6fcbaaf6f72fe46a6d911b033dfea0">More...</a><br /></td></tr>
<tr class="separator:a5f6fcbaaf6f72fe46a6d911b033dfea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb296eab4ca31ab5c0cf4a932488a8de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de">memmove_s</a> (void *dest, size_t sizeInBytes, const void *src, size_t count)</td></tr>
<tr class="memdesc:adb296eab4ca31ab5c0cf4a932488a8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounds checking replacement for memmove()  <a href="#adb296eab4ca31ab5c0cf4a932488a8de">More...</a><br /></td></tr>
<tr class="separator:adb296eab4ca31ab5c0cf4a932488a8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810542d642def73fd278c08092417e11"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a810542d642def73fd278c08092417e11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a810542d642def73fd278c08092417e11">vec_swap</a> (T &amp;a, T &amp;b)</td></tr>
<tr class="memdesc:a810542d642def73fd278c08092417e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two variables which are arrays.  <a href="#a810542d642def73fd278c08092417e11">More...</a><br /></td></tr>
<tr class="separator:a810542d642def73fd278c08092417e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8804f66768d757773489cde7738df1e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#ab8804f66768d757773489cde7738df1e">memset_z</a> (void *ptr, int value, size_t num)</td></tr>
<tr class="memdesc:ab8804f66768d757773489cde7738df1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory block initializer and eraser that attempts to survive optimizations.  <a href="#ab8804f66768d757773489cde7738df1e">More...</a><br /></td></tr>
<tr class="separator:ab8804f66768d757773489cde7738df1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe412b0409249cb54899e97bc7d86424"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abe412b0409249cb54899e97bc7d86424"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#abe412b0409249cb54899e97bc7d86424">STDMIN</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:abe412b0409249cb54899e97bc7d86424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replacement function for std::min.  <a href="#abe412b0409249cb54899e97bc7d86424">More...</a><br /></td></tr>
<tr class="separator:abe412b0409249cb54899e97bc7d86424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1490597cb11989e78d5ba5b5f21266b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af1490597cb11989e78d5ba5b5f21266b"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#af1490597cb11989e78d5ba5b5f21266b">STDMAX</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:af1490597cb11989e78d5ba5b5f21266b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replacement function for std::max.  <a href="#af1490597cb11989e78d5ba5b5f21266b">More...</a><br /></td></tr>
<tr class="separator:af1490597cb11989e78d5ba5b5f21266b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8391e7d9d613a6c401787d2cdab1f51"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ac8391e7d9d613a6c401787d2cdab1f51"><td class="memTemplItemLeft" align="right" valign="top">const T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#ac8391e7d9d613a6c401787d2cdab1f51">UnsignedMin</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:ac8391e7d9d613a6c401787d2cdab1f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe comparison of values that could be neagtive and incorrectly promoted.  <a href="#ac8391e7d9d613a6c401787d2cdab1f51">More...</a><br /></td></tr>
<tr class="separator:ac8391e7d9d613a6c401787d2cdab1f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2ce94589bb74164d809f4675bd23dd"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a8a2ce94589bb74164d809f4675bd23dd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a8a2ce94589bb74164d809f4675bd23dd">SafeConvert</a> (T1 from, T2 &amp;to)</td></tr>
<tr class="memdesc:a8a2ce94589bb74164d809f4675bd23dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a conversion from -&gt; to is safe to perform.  <a href="#a8a2ce94589bb74164d809f4675bd23dd">More...</a><br /></td></tr>
<tr class="separator:a8a2ce94589bb74164d809f4675bd23dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd7decd035cc4e144cd3d395e834106"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6cd7decd035cc4e144cd3d395e834106"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a6cd7decd035cc4e144cd3d395e834106">IntToString</a> (T value, unsigned int base=10)</td></tr>
<tr class="memdesc:a6cd7decd035cc4e144cd3d395e834106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a value to a string.  <a href="#a6cd7decd035cc4e144cd3d395e834106">More...</a><br /></td></tr>
<tr class="separator:a6cd7decd035cc4e144cd3d395e834106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4f4608b867f01a4cad90c5b222f89b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aad4f4608b867f01a4cad90c5b222f89b"><td class="memTemplItemLeft" align="right" valign="top">CRYPTOPP_DLL std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#aad4f4608b867f01a4cad90c5b222f89b">IntToString&lt; word64 &gt;</a> (word64 value, unsigned int base)</td></tr>
<tr class="memdesc:aad4f4608b867f01a4cad90c5b222f89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an unsigned value to a string.  <a href="#aad4f4608b867f01a4cad90c5b222f89b">More...</a><br /></td></tr>
<tr class="separator:aad4f4608b867f01a4cad90c5b222f89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b67e971e2ab82125e3cf2a08a24a103"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a1b67e971e2ab82125e3cf2a08a24a103"><td class="memTemplItemLeft" align="right" valign="top">CRYPTOPP_DLL std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a1b67e971e2ab82125e3cf2a08a24a103">IntToString&lt; Integer &gt;</a> (<a class="el" href="class_integer.html">Integer</a> value, unsigned int base)</td></tr>
<tr class="memdesc:a1b67e971e2ab82125e3cf2a08a24a103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="class_integer.html" title="Multiple precision integer with arithmetic operations. ">Integer</a> to a string.  <a href="#a1b67e971e2ab82125e3cf2a08a24a103">More...</a><br /></td></tr>
<tr class="separator:a1b67e971e2ab82125e3cf2a08a24a103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c63a5683602db0ff8975746a414797f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6c63a5683602db0ff8975746a414797f"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a6c63a5683602db0ff8975746a414797f">Parity</a> (T value)</td></tr>
<tr class="memdesc:a6c63a5683602db0ff8975746a414797f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parity of a value.  <a href="#a6c63a5683602db0ff8975746a414797f">More...</a><br /></td></tr>
<tr class="separator:a6c63a5683602db0ff8975746a414797f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e22fbd4b8f95aa01bde93ea32e44e82"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3e22fbd4b8f95aa01bde93ea32e44e82"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a3e22fbd4b8f95aa01bde93ea32e44e82">BytePrecision</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a3e22fbd4b8f95aa01bde93ea32e44e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of 8-bit bytes or octets required for a value.  <a href="#a3e22fbd4b8f95aa01bde93ea32e44e82">More...</a><br /></td></tr>
<tr class="separator:a3e22fbd4b8f95aa01bde93ea32e44e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5964768bc94670ad2bc3f218d9367f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3c5964768bc94670ad2bc3f218d9367f"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a3c5964768bc94670ad2bc3f218d9367f">BitPrecision</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a3c5964768bc94670ad2bc3f218d9367f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bits required for a value.  <a href="#a3c5964768bc94670ad2bc3f218d9367f">More...</a><br /></td></tr>
<tr class="separator:a3c5964768bc94670ad2bc3f218d9367f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495acbd6f3cdabbb4dd863c09b378df4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a495acbd6f3cdabbb4dd863c09b378df4">TrailingZeros</a> (word32 v)</td></tr>
<tr class="memdesc:a495acbd6f3cdabbb4dd863c09b378df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of trailing 0-bits in a value.  <a href="#a495acbd6f3cdabbb4dd863c09b378df4">More...</a><br /></td></tr>
<tr class="separator:a495acbd6f3cdabbb4dd863c09b378df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb4df9b2f1e119d89a1573338c4eda6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#addb4df9b2f1e119d89a1573338c4eda6">TrailingZeros</a> (word64 v)</td></tr>
<tr class="memdesc:addb4df9b2f1e119d89a1573338c4eda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of trailing 0-bits in a value.  <a href="#addb4df9b2f1e119d89a1573338c4eda6">More...</a><br /></td></tr>
<tr class="separator:addb4df9b2f1e119d89a1573338c4eda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616a7f0365c4947b0c8a44606c525a62"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a616a7f0365c4947b0c8a44606c525a62"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a616a7f0365c4947b0c8a44606c525a62">Crop</a> (T value, size_t bits)</td></tr>
<tr class="memdesc:a616a7f0365c4947b0c8a44606c525a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncates the value to the specified number of bits.  <a href="#a616a7f0365c4947b0c8a44606c525a62">More...</a><br /></td></tr>
<tr class="separator:a616a7f0365c4947b0c8a44606c525a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5d30b17c9d4869fdc3458dd05c500d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a7c5d30b17c9d4869fdc3458dd05c500d">BitsToBytes</a> (size_t bitCount)</td></tr>
<tr class="memdesc:a7c5d30b17c9d4869fdc3458dd05c500d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of 8-bit bytes or octets required for the specified number of bits.  <a href="#a7c5d30b17c9d4869fdc3458dd05c500d">More...</a><br /></td></tr>
<tr class="separator:a7c5d30b17c9d4869fdc3458dd05c500d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886cc7ce76578c6df939f564f676e71a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a886cc7ce76578c6df939f564f676e71a">BytesToWords</a> (size_t byteCount)</td></tr>
<tr class="memdesc:a886cc7ce76578c6df939f564f676e71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of words required for the specified number of bytes.  <a href="#a886cc7ce76578c6df939f564f676e71a">More...</a><br /></td></tr>
<tr class="separator:a886cc7ce76578c6df939f564f676e71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c56601a8c94b6a37a21657929fe928"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a45c56601a8c94b6a37a21657929fe928">BitsToWords</a> (size_t bitCount)</td></tr>
<tr class="memdesc:a45c56601a8c94b6a37a21657929fe928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of words required for the specified number of bits.  <a href="#a45c56601a8c94b6a37a21657929fe928">More...</a><br /></td></tr>
<tr class="separator:a45c56601a8c94b6a37a21657929fe928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778d13f3d45915e1bc5c0ab1801ea6ad"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a778d13f3d45915e1bc5c0ab1801ea6ad">BitsToDwords</a> (size_t bitCount)</td></tr>
<tr class="memdesc:a778d13f3d45915e1bc5c0ab1801ea6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of double words required for the specified number of bits.  <a href="#a778d13f3d45915e1bc5c0ab1801ea6ad">More...</a><br /></td></tr>
<tr class="separator:a778d13f3d45915e1bc5c0ab1801ea6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2088e041288c140d06e1fba844e6e9"><td class="memItemLeft" align="right" valign="top">CRYPTOPP_DLL void CRYPTOPP_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a7d2088e041288c140d06e1fba844e6e9">xorbuf</a> (byte *buf, const byte *mask, size_t count)</td></tr>
<tr class="memdesc:a7d2088e041288c140d06e1fba844e6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an XOR of a buffer with a mask.  <a href="#a7d2088e041288c140d06e1fba844e6e9">More...</a><br /></td></tr>
<tr class="separator:a7d2088e041288c140d06e1fba844e6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db8a951de8dbc133bc845e21d2c59ae"><td class="memItemLeft" align="right" valign="top">CRYPTOPP_DLL void CRYPTOPP_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a4db8a951de8dbc133bc845e21d2c59ae">xorbuf</a> (byte *output, const byte *input, const byte *mask, size_t count)</td></tr>
<tr class="memdesc:a4db8a951de8dbc133bc845e21d2c59ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an XOR of an input buffer with a mask and stores the result in an output buffer.  <a href="#a4db8a951de8dbc133bc845e21d2c59ae">More...</a><br /></td></tr>
<tr class="separator:a4db8a951de8dbc133bc845e21d2c59ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1c626f8d491a96c517b5a165b60be5"><td class="memItemLeft" align="right" valign="top">CRYPTOPP_DLL bool CRYPTOPP_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a9f1c626f8d491a96c517b5a165b60be5">VerifyBufsEqual</a> (const byte *buf1, const byte *buf2, size_t count)</td></tr>
<tr class="memdesc:a9f1c626f8d491a96c517b5a165b60be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a near constant-time comparison of two equally sized buffers.  <a href="#a9f1c626f8d491a96c517b5a165b60be5">More...</a><br /></td></tr>
<tr class="separator:a9f1c626f8d491a96c517b5a165b60be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65531618a7eca8803fa9e9287c43aafc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a65531618a7eca8803fa9e9287c43aafc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a65531618a7eca8803fa9e9287c43aafc">IsPowerOf2</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a65531618a7eca8803fa9e9287c43aafc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a value is a power of 2.  <a href="#a65531618a7eca8803fa9e9287c43aafc">More...</a><br /></td></tr>
<tr class="separator:a65531618a7eca8803fa9e9287c43aafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30712a90999ad9d9152975f2e92d46b8"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a30712a90999ad9d9152975f2e92d46b8"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a30712a90999ad9d9152975f2e92d46b8">SaturatingSubtract</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a30712a90999ad9d9152975f2e92d46b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a saturating subtract clamped at 0.  <a href="#a30712a90999ad9d9152975f2e92d46b8">More...</a><br /></td></tr>
<tr class="separator:a30712a90999ad9d9152975f2e92d46b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd39d67faef904dbb474981762b7ebe1"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:afd39d67faef904dbb474981762b7ebe1"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#afd39d67faef904dbb474981762b7ebe1">SaturatingSubtract1</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:afd39d67faef904dbb474981762b7ebe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a saturating subtract clamped at 1.  <a href="#afd39d67faef904dbb474981762b7ebe1">More...</a><br /></td></tr>
<tr class="separator:afd39d67faef904dbb474981762b7ebe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621695f6346d6a745e340513d917b31a"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a621695f6346d6a745e340513d917b31a"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a621695f6346d6a745e340513d917b31a">ModPowerOf2</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a621695f6346d6a745e340513d917b31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces a value to a power of 2.  <a href="#a621695f6346d6a745e340513d917b31a">More...</a><br /></td></tr>
<tr class="separator:a621695f6346d6a745e340513d917b31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ac57210cb6796eced074e6d2e294fb"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:aa2ac57210cb6796eced074e6d2e294fb"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#aa2ac57210cb6796eced074e6d2e294fb">RoundDownToMultipleOf</a> (const T1 &amp;n, const T2 &amp;m)</td></tr>
<tr class="memdesc:aa2ac57210cb6796eced074e6d2e294fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds a value down to a multiple of a second value.  <a href="#aa2ac57210cb6796eced074e6d2e294fb">More...</a><br /></td></tr>
<tr class="separator:aa2ac57210cb6796eced074e6d2e294fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a219d44f45272a1f3b3f17a656000a"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a57a219d44f45272a1f3b3f17a656000a"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a57a219d44f45272a1f3b3f17a656000a">RoundUpToMultipleOf</a> (const T1 &amp;n, const T2 &amp;m)</td></tr>
<tr class="memdesc:a57a219d44f45272a1f3b3f17a656000a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds a value up to a multiple of a second value.  <a href="#a57a219d44f45272a1f3b3f17a656000a">More...</a><br /></td></tr>
<tr class="separator:a57a219d44f45272a1f3b3f17a656000a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e438054095c88f0c4d9eda7efc584d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab4e438054095c88f0c4d9eda7efc584d"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#ab4e438054095c88f0c4d9eda7efc584d">GetAlignmentOf</a> ()</td></tr>
<tr class="memdesc:ab4e438054095c88f0c4d9eda7efc584d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum alignment requirements of a type.  <a href="#ab4e438054095c88f0c4d9eda7efc584d">More...</a><br /></td></tr>
<tr class="separator:ab4e438054095c88f0c4d9eda7efc584d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726c3b76265182681f5d5fd173ab5676"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a726c3b76265182681f5d5fd173ab5676">IsAlignedOn</a> (const void *ptr, unsigned int alignment)</td></tr>
<tr class="memdesc:a726c3b76265182681f5d5fd173ab5676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether ptr is aligned to a minimum value.  <a href="#a726c3b76265182681f5d5fd173ab5676">More...</a><br /></td></tr>
<tr class="separator:a726c3b76265182681f5d5fd173ab5676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2c95659d16a971941622625c9102ae"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8b2c95659d16a971941622625c9102ae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a8b2c95659d16a971941622625c9102ae">IsAligned</a> (const void *ptr)</td></tr>
<tr class="memdesc:a8b2c95659d16a971941622625c9102ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether ptr is minimally aligned.  <a href="#a8b2c95659d16a971941622625c9102ae">More...</a><br /></td></tr>
<tr class="separator:a8b2c95659d16a971941622625c9102ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8336b0d98f2469441837be6cbbebf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#aed8336b0d98f2469441837be6cbbebf9">GetNativeByteOrder</a> ()</td></tr>
<tr class="memdesc:aed8336b0d98f2469441837be6cbbebf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns NativeByteOrder as an enumerated ByteOrder value.  <a href="#aed8336b0d98f2469441837be6cbbebf9">More...</a><br /></td></tr>
<tr class="separator:aed8336b0d98f2469441837be6cbbebf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2da0dd866619761e63c3b5da58c477"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a6c2da0dd866619761e63c3b5da58c477">NativeByteOrderIs</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order)</td></tr>
<tr class="memdesc:a6c2da0dd866619761e63c3b5da58c477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether order follows native byte ordering.  <a href="#a6c2da0dd866619761e63c3b5da58c477">More...</a><br /></td></tr>
<tr class="separator:a6c2da0dd866619761e63c3b5da58c477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade22f7ed542b3db2912c917f8e3d6067"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ade22f7ed542b3db2912c917f8e3d6067"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="cryptlib_8h.html#a353ccabf5ddc119a6a33e92f7b9961c7">CipherDir</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#ade22f7ed542b3db2912c917f8e3d6067">GetCipherDir</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:ade22f7ed542b3db2912c917f8e3d6067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the direction the cipher is being operated.  <a href="#ade22f7ed542b3db2912c917f8e3d6067">More...</a><br /></td></tr>
<tr class="separator:ade22f7ed542b3db2912c917f8e3d6067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f5dcab97ccb3e9449d487dd37ffc7a"><td class="memItemLeft" align="right" valign="top">CRYPTOPP_DLL void CRYPTOPP_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#ab0f5dcab97ccb3e9449d487dd37ffc7a">CallNewHandler</a> ()</td></tr>
<tr class="memdesc:ab0f5dcab97ccb3e9449d487dd37ffc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to reclaim unused memory.  <a href="#ab0f5dcab97ccb3e9449d487dd37ffc7a">More...</a><br /></td></tr>
<tr class="separator:ab0f5dcab97ccb3e9449d487dd37ffc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fad9d8c25e8aca3a7ee29345516f0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a44fad9d8c25e8aca3a7ee29345516f0a">IncrementCounterByOne</a> (byte *inout, unsigned int size)</td></tr>
<tr class="memdesc:a44fad9d8c25e8aca3a7ee29345516f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an addition with carry on a block of bytes.  <a href="#a44fad9d8c25e8aca3a7ee29345516f0a">More...</a><br /></td></tr>
<tr class="separator:a44fad9d8c25e8aca3a7ee29345516f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f852960b51e106a849781341cb2055c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a2f852960b51e106a849781341cb2055c">IncrementCounterByOne</a> (byte *output, const byte *input, unsigned int size)</td></tr>
<tr class="memdesc:a2f852960b51e106a849781341cb2055c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an addition with carry on a block of bytes.  <a href="#a2f852960b51e106a849781341cb2055c">More...</a><br /></td></tr>
<tr class="separator:a2f852960b51e106a849781341cb2055c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71e5659910553da22f9b1e877cddc07"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae71e5659910553da22f9b1e877cddc07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#ae71e5659910553da22f9b1e877cddc07">ConditionalSwap</a> (bool c, T &amp;a, T &amp;b)</td></tr>
<tr class="memdesc:ae71e5659910553da22f9b1e877cddc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a branchless swap of values a and b if condition c is true.  <a href="#ae71e5659910553da22f9b1e877cddc07">More...</a><br /></td></tr>
<tr class="separator:ae71e5659910553da22f9b1e877cddc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513e4522b268f9ee2e188606c2101d5a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a513e4522b268f9ee2e188606c2101d5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a513e4522b268f9ee2e188606c2101d5a">ConditionalSwapPointers</a> (bool c, T &amp;a, T &amp;b)</td></tr>
<tr class="memdesc:a513e4522b268f9ee2e188606c2101d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a branchless swap of pointers a and b if condition c is true.  <a href="#a513e4522b268f9ee2e188606c2101d5a">More...</a><br /></td></tr>
<tr class="separator:a513e4522b268f9ee2e188606c2101d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656f38b8d0440981f5f013ada782018c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a656f38b8d0440981f5f013ada782018c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a656f38b8d0440981f5f013ada782018c">SecureWipeBuffer</a> (T *buf, size_t n)</td></tr>
<tr class="memdesc:a656f38b8d0440981f5f013ada782018c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each element of an array to 0.  <a href="#a656f38b8d0440981f5f013ada782018c">More...</a><br /></td></tr>
<tr class="separator:a656f38b8d0440981f5f013ada782018c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4994f3480634e5f1435fd71f9b652c38"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4994f3480634e5f1435fd71f9b652c38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a4994f3480634e5f1435fd71f9b652c38">SecureWipeArray</a> (T *buf, size_t n)</td></tr>
<tr class="memdesc:a4994f3480634e5f1435fd71f9b652c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each element of an array to 0.  <a href="#a4994f3480634e5f1435fd71f9b652c38">More...</a><br /></td></tr>
<tr class="separator:a4994f3480634e5f1435fd71f9b652c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2ed56f8a15d6dabbef74390eda4352"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#aba2ed56f8a15d6dabbef74390eda4352">StringNarrow</a> (const wchar_t *str, bool throwOnError=true)</td></tr>
<tr class="memdesc:aba2ed56f8a15d6dabbef74390eda4352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a wide character C-string to a multibyte string.  <a href="#aba2ed56f8a15d6dabbef74390eda4352">More...</a><br /></td></tr>
<tr class="separator:aba2ed56f8a15d6dabbef74390eda4352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95ff706a83782e3d18a3d14817db932"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#ac95ff706a83782e3d18a3d14817db932">StringWiden</a> (const char *str, bool throwOnError=true)</td></tr>
<tr class="memdesc:ac95ff706a83782e3d18a3d14817db932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a multibyte C-string to a wide character string.  <a href="#ac95ff706a83782e3d18a3d14817db932">More...</a><br /></td></tr>
<tr class="separator:ac95ff706a83782e3d18a3d14817db932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0175d502d0936c6692e39fc976a294"><td class="memItemLeft" align="right" valign="top">CRYPTOPP_DLL void *CRYPTOPP_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#acf0175d502d0936c6692e39fc976a294">UnalignedAllocate</a> (size_t size)</td></tr>
<tr class="memdesc:acf0175d502d0936c6692e39fc976a294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a buffer.  <a href="#acf0175d502d0936c6692e39fc976a294">More...</a><br /></td></tr>
<tr class="separator:acf0175d502d0936c6692e39fc976a294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55427b31e548a01ab518279b60cee025"><td class="memItemLeft" align="right" valign="top">CRYPTOPP_DLL void CRYPTOPP_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a55427b31e548a01ab518279b60cee025">UnalignedDeallocate</a> (void *ptr)</td></tr>
<tr class="memdesc:a55427b31e548a01ab518279b60cee025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a buffer allocated with UnalignedAllocate.  <a href="#a55427b31e548a01ab518279b60cee025">More...</a><br /></td></tr>
<tr class="separator:a55427b31e548a01ab518279b60cee025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7b80a08d25ab9d62693c9e4798ef98"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aaf7b80a08d25ab9d62693c9e4798ef98"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#aaf7b80a08d25ab9d62693c9e4798ef98">rotlFixed</a> (T x, unsigned int y)</td></tr>
<tr class="memdesc:aaf7b80a08d25ab9d62693c9e4798ef98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotate.  <a href="#aaf7b80a08d25ab9d62693c9e4798ef98">More...</a><br /></td></tr>
<tr class="separator:aaf7b80a08d25ab9d62693c9e4798ef98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf88e95400925b89c94641916535b6da"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abf88e95400925b89c94641916535b6da"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#abf88e95400925b89c94641916535b6da">rotrFixed</a> (T x, unsigned int y)</td></tr>
<tr class="memdesc:abf88e95400925b89c94641916535b6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a right rotate.  <a href="#abf88e95400925b89c94641916535b6da">More...</a><br /></td></tr>
<tr class="separator:abf88e95400925b89c94641916535b6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de05253683b27a221e6465b3a7453b2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0de05253683b27a221e6465b3a7453b2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a0de05253683b27a221e6465b3a7453b2">rotlVariable</a> (T x, unsigned int y)</td></tr>
<tr class="memdesc:a0de05253683b27a221e6465b3a7453b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotate.  <a href="#a0de05253683b27a221e6465b3a7453b2">More...</a><br /></td></tr>
<tr class="separator:a0de05253683b27a221e6465b3a7453b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd053d245fe902fe55bfd8a335634110"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abd053d245fe902fe55bfd8a335634110"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#abd053d245fe902fe55bfd8a335634110">rotrVariable</a> (T x, unsigned int y)</td></tr>
<tr class="memdesc:abd053d245fe902fe55bfd8a335634110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a right rotate.  <a href="#abd053d245fe902fe55bfd8a335634110">More...</a><br /></td></tr>
<tr class="separator:abd053d245fe902fe55bfd8a335634110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31fe5d559d014085c6a49594b817196"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad31fe5d559d014085c6a49594b817196"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#ad31fe5d559d014085c6a49594b817196">rotlMod</a> (T x, unsigned int y)</td></tr>
<tr class="memdesc:ad31fe5d559d014085c6a49594b817196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotate.  <a href="#ad31fe5d559d014085c6a49594b817196">More...</a><br /></td></tr>
<tr class="separator:ad31fe5d559d014085c6a49594b817196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fc34eb834dd2424407d5e4d729594e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae8fc34eb834dd2424407d5e4d729594e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#ae8fc34eb834dd2424407d5e4d729594e">rotrMod</a> (T x, unsigned int y)</td></tr>
<tr class="memdesc:ae8fc34eb834dd2424407d5e4d729594e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a right rotate.  <a href="#ae8fc34eb834dd2424407d5e4d729594e">More...</a><br /></td></tr>
<tr class="separator:ae8fc34eb834dd2424407d5e4d729594e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2ceb73851e757cb436cdbaa0242219"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9a2ceb73851e757cb436cdbaa0242219"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a9a2ceb73851e757cb436cdbaa0242219">GetByte</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, T value, unsigned int index)</td></tr>
<tr class="memdesc:a9a2ceb73851e757cb436cdbaa0242219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a byte from a value.  <a href="#a9a2ceb73851e757cb436cdbaa0242219">More...</a><br /></td></tr>
<tr class="separator:a9a2ceb73851e757cb436cdbaa0242219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8d5adca8384ebedc699760ce217b08"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a1d8d5adca8384ebedc699760ce217b08">ByteReverse</a> (byte value)</td></tr>
<tr class="memdesc:a1d8d5adca8384ebedc699760ce217b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bytes in a 8-bit value.  <a href="#a1d8d5adca8384ebedc699760ce217b08">More...</a><br /></td></tr>
<tr class="separator:a1d8d5adca8384ebedc699760ce217b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa179e009cf5c74bb431b3c112d7ee444"><td class="memItemLeft" align="right" valign="top">word16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#aa179e009cf5c74bb431b3c112d7ee444">ByteReverse</a> (word16 value)</td></tr>
<tr class="memdesc:aa179e009cf5c74bb431b3c112d7ee444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bytes in a 16-bit value.  <a href="#aa179e009cf5c74bb431b3c112d7ee444">More...</a><br /></td></tr>
<tr class="separator:aa179e009cf5c74bb431b3c112d7ee444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf65f4a9edb6224d01e900aa7205a4f4"><td class="memItemLeft" align="right" valign="top">word32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#acf65f4a9edb6224d01e900aa7205a4f4">ByteReverse</a> (word32 value)</td></tr>
<tr class="memdesc:acf65f4a9edb6224d01e900aa7205a4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bytes in a 32-bit value.  <a href="#acf65f4a9edb6224d01e900aa7205a4f4">More...</a><br /></td></tr>
<tr class="separator:acf65f4a9edb6224d01e900aa7205a4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47686f3b4957541a58a3b280d1a89d4c"><td class="memItemLeft" align="right" valign="top">word64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a47686f3b4957541a58a3b280d1a89d4c">ByteReverse</a> (word64 value)</td></tr>
<tr class="memdesc:a47686f3b4957541a58a3b280d1a89d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bytes in a 64-bit value.  <a href="#a47686f3b4957541a58a3b280d1a89d4c">More...</a><br /></td></tr>
<tr class="separator:a47686f3b4957541a58a3b280d1a89d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1746e70bf831f0cbf8ad73d8c15bc921"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a1746e70bf831f0cbf8ad73d8c15bc921">BitReverse</a> (byte value)</td></tr>
<tr class="memdesc:a1746e70bf831f0cbf8ad73d8c15bc921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bits in a 8-bit value.  <a href="#a1746e70bf831f0cbf8ad73d8c15bc921">More...</a><br /></td></tr>
<tr class="separator:a1746e70bf831f0cbf8ad73d8c15bc921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699c24d7013f20ee03076576984c875e"><td class="memItemLeft" align="right" valign="top">word16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a699c24d7013f20ee03076576984c875e">BitReverse</a> (word16 value)</td></tr>
<tr class="memdesc:a699c24d7013f20ee03076576984c875e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bits in a 16-bit value.  <a href="#a699c24d7013f20ee03076576984c875e">More...</a><br /></td></tr>
<tr class="separator:a699c24d7013f20ee03076576984c875e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad87ebeafa7de2c11c19453f3b3cfea7"><td class="memItemLeft" align="right" valign="top">word32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#aad87ebeafa7de2c11c19453f3b3cfea7">BitReverse</a> (word32 value)</td></tr>
<tr class="memdesc:aad87ebeafa7de2c11c19453f3b3cfea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bits in a 32-bit value.  <a href="#aad87ebeafa7de2c11c19453f3b3cfea7">More...</a><br /></td></tr>
<tr class="separator:aad87ebeafa7de2c11c19453f3b3cfea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336c0289dcd2670e6b4079fa98018d7a"><td class="memItemLeft" align="right" valign="top">word64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html#a336c0289dcd2670e6b4079fa98018d7a">BitReverse</a> (word64 value)</td></tr>
<tr class="memdesc:a336c0289dcd2670e6b4079fa98018d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bits in a 64-bit value.  <a href="#a336c0289dcd2670e6b4079fa98018d7a">More...</a><br /></td></tr>
<tr class="separator:a336c0289dcd2670e6b4079fa98018d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641ecc1d620ac8c04bc43661a2bbba71"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a641ecc1d620ac8c04bc43661a2bbba71"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a641ecc1d620ac8c04bc43661a2bbba71">BitReverse</a> (T value)</td></tr>
<tr class="memdesc:a641ecc1d620ac8c04bc43661a2bbba71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bits in a value.  <a href="#a641ecc1d620ac8c04bc43661a2bbba71">More...</a><br /></td></tr>
<tr class="separator:a641ecc1d620ac8c04bc43661a2bbba71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e499ded4f2e7e7705c3cfd39cdf137f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8e499ded4f2e7e7705c3cfd39cdf137f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a8e499ded4f2e7e7705c3cfd39cdf137f">ConditionalByteReverse</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, T value)</td></tr>
<tr class="memdesc:a8e499ded4f2e7e7705c3cfd39cdf137f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bytes in a value depending upon endianness.  <a href="#a8e499ded4f2e7e7705c3cfd39cdf137f">More...</a><br /></td></tr>
<tr class="separator:a8e499ded4f2e7e7705c3cfd39cdf137f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95e030e0abd33ea360d75cd9c4c8bbe"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab95e030e0abd33ea360d75cd9c4c8bbe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#ab95e030e0abd33ea360d75cd9c4c8bbe">ByteReverse</a> (T *out, const T *in, size_t byteCount)</td></tr>
<tr class="memdesc:ab95e030e0abd33ea360d75cd9c4c8bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bytes in an element from an array of elements.  <a href="#ab95e030e0abd33ea360d75cd9c4c8bbe">More...</a><br /></td></tr>
<tr class="separator:ab95e030e0abd33ea360d75cd9c4c8bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0de65c1758668440f71a8ff6534ad9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aae0de65c1758668440f71a8ff6534ad9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#aae0de65c1758668440f71a8ff6534ad9">ConditionalByteReverse</a> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, T *out, const T *in, size_t byteCount)</td></tr>
<tr class="memdesc:aae0de65c1758668440f71a8ff6534ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally reverses bytes in an element from an array of elements.  <a href="#aae0de65c1758668440f71a8ff6534ad9">More...</a><br /></td></tr>
<tr class="separator:aae0de65c1758668440f71a8ff6534ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929e347e6efedee4099dac8b3956350e"><td class="memTemplParams" colspan="2"><a id="a929e347e6efedee4099dac8b3956350e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a929e347e6efedee4099dac8b3956350e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetUserKey</b> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, T *out, size_t outlen, const byte *in, size_t inlen)</td></tr>
<tr class="separator:a929e347e6efedee4099dac8b3956350e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee7b3ac15dde684911fb0358d72539b"><td class="memItemLeft" align="right" valign="top"><a id="a5ee7b3ac15dde684911fb0358d72539b"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><b>UnalignedGetWordNonTemplate</b> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, const byte *<a class="el" href="structblock__.html">block</a>, const byte *)</td></tr>
<tr class="separator:a5ee7b3ac15dde684911fb0358d72539b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca0a65d7e2525ef590fa40323cd896a"><td class="memItemLeft" align="right" valign="top"><a id="aeca0a65d7e2525ef590fa40323cd896a"></a>
word16&#160;</td><td class="memItemRight" valign="bottom"><b>UnalignedGetWordNonTemplate</b> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, const byte *<a class="el" href="structblock__.html">block</a>, const word16 *)</td></tr>
<tr class="separator:aeca0a65d7e2525ef590fa40323cd896a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba08e8808a65a1d19f383f700d9dd85d"><td class="memItemLeft" align="right" valign="top"><a id="aba08e8808a65a1d19f383f700d9dd85d"></a>
word32&#160;</td><td class="memItemRight" valign="bottom"><b>UnalignedGetWordNonTemplate</b> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, const byte *<a class="el" href="structblock__.html">block</a>, const word32 *)</td></tr>
<tr class="separator:aba08e8808a65a1d19f383f700d9dd85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad41371a8bd7ba794fc7d4fe58234f00"><td class="memItemLeft" align="right" valign="top"><a id="aad41371a8bd7ba794fc7d4fe58234f00"></a>
word64&#160;</td><td class="memItemRight" valign="bottom"><b>UnalignedGetWordNonTemplate</b> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, const byte *<a class="el" href="structblock__.html">block</a>, const word64 *)</td></tr>
<tr class="separator:aad41371a8bd7ba794fc7d4fe58234f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8184a77f9a4c8ffbda9622b1cee7a148"><td class="memItemLeft" align="right" valign="top"><a id="a8184a77f9a4c8ffbda9622b1cee7a148"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UnalignedbyteNonTemplate</b> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, byte *<a class="el" href="structblock__.html">block</a>, byte value, const byte *xorBlock)</td></tr>
<tr class="separator:a8184a77f9a4c8ffbda9622b1cee7a148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26b43699857ac54a8f4624c89bb6ab9"><td class="memItemLeft" align="right" valign="top"><a id="ac26b43699857ac54a8f4624c89bb6ab9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UnalignedbyteNonTemplate</b> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, byte *<a class="el" href="structblock__.html">block</a>, word16 value, const byte *xorBlock)</td></tr>
<tr class="separator:ac26b43699857ac54a8f4624c89bb6ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9d0bbf3f776108244b5c36ff5041d5"><td class="memItemLeft" align="right" valign="top"><a id="aef9d0bbf3f776108244b5c36ff5041d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UnalignedbyteNonTemplate</b> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, byte *<a class="el" href="structblock__.html">block</a>, word32 value, const byte *xorBlock)</td></tr>
<tr class="separator:aef9d0bbf3f776108244b5c36ff5041d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bf3fa1752839aa454537cd2d3ca935"><td class="memItemLeft" align="right" valign="top"><a id="a36bf3fa1752839aa454537cd2d3ca935"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UnalignedbyteNonTemplate</b> (<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, byte *<a class="el" href="structblock__.html">block</a>, word64 value, const byte *xorBlock)</td></tr>
<tr class="separator:a36bf3fa1752839aa454537cd2d3ca935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240e8e97f964626508362b59b78532d3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a240e8e97f964626508362b59b78532d3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a240e8e97f964626508362b59b78532d3">GetWord</a> (bool assumeAligned, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, const byte *<a class="el" href="structblock__.html">block</a>)</td></tr>
<tr class="memdesc:a240e8e97f964626508362b59b78532d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a block of memory.  <a href="#a240e8e97f964626508362b59b78532d3">More...</a><br /></td></tr>
<tr class="separator:a240e8e97f964626508362b59b78532d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4546cdeeecddedd3a0f784ea6b80c8bd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4546cdeeecddedd3a0f784ea6b80c8bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a4546cdeeecddedd3a0f784ea6b80c8bd">GetWord</a> (bool assumeAligned, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, T &amp;result, const byte *<a class="el" href="structblock__.html">block</a>)</td></tr>
<tr class="memdesc:a4546cdeeecddedd3a0f784ea6b80c8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a block of memory.  <a href="#a4546cdeeecddedd3a0f784ea6b80c8bd">More...</a><br /></td></tr>
<tr class="separator:a4546cdeeecddedd3a0f784ea6b80c8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096e90ab9bb746edf908d25f0856a786"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a096e90ab9bb746edf908d25f0856a786"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a096e90ab9bb746edf908d25f0856a786">PutWord</a> (bool assumeAligned, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order, byte *<a class="el" href="structblock__.html">block</a>, T value, const byte *xorBlock=NULLPTR)</td></tr>
<tr class="memdesc:a096e90ab9bb746edf908d25f0856a786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a block of memory.  <a href="#a096e90ab9bb746edf908d25f0856a786">More...</a><br /></td></tr>
<tr class="separator:a096e90ab9bb746edf908d25f0856a786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a35b59a1f2e23b94ed2f74f0594613"><td class="memTemplParams" colspan="2"><a id="a18a35b59a1f2e23b94ed2f74f0594613"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a18a35b59a1f2e23b94ed2f74f0594613"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>WordToString</b> (T value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>)</td></tr>
<tr class="separator:a18a35b59a1f2e23b94ed2f74f0594613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23234e96107b28512db9467c33f67590"><td class="memTemplParams" colspan="2"><a id="a23234e96107b28512db9467c33f67590"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a23234e96107b28512db9467c33f67590"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StringToWord</b> (const std::string &amp;str, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>)</td></tr>
<tr class="separator:a23234e96107b28512db9467c33f67590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda5071e4c754b612b6a4c42be421312"><td class="memTemplParams" colspan="2">template&lt;unsigned int bits, class T &gt; </td></tr>
<tr class="memitem:abda5071e4c754b612b6a4c42be421312"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#abda5071e4c754b612b6a4c42be421312">SafeRightShift</a> (T value)</td></tr>
<tr class="memdesc:abda5071e4c754b612b6a4c42be421312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely right shift values when undefined behavior could occur.  <a href="#abda5071e4c754b612b6a4c42be421312">More...</a><br /></td></tr>
<tr class="separator:abda5071e4c754b612b6a4c42be421312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e2662974095094e345b2bc2b30ee4c"><td class="memTemplParams" colspan="2">template&lt;unsigned int bits, class T &gt; </td></tr>
<tr class="memitem:a45e2662974095094e345b2bc2b30ee4c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="misc_8h.html#a45e2662974095094e345b2bc2b30ee4c">SafeLeftShift</a> (T value)</td></tr>
<tr class="memdesc:a45e2662974095094e345b2bc2b30ee4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely left shift values when undefined behavior could occur.  <a href="#a45e2662974095094e345b2bc2b30ee4c">More...</a><br /></td></tr>
<tr class="separator:a45e2662974095094e345b2bc2b30ee4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility functions for the Crypto++ library. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a4002b9b8cfe3baff72fc606a0525c2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4002b9b8cfe3baff72fc606a0525c2fe">&#9670;&nbsp;</a></span>CRYPTOPP_COMPILE_ASSERT_INSTANCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRYPTOPP_COMPILE_ASSERT_INSTANCE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">assertion, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">instance&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code" href="struct_compile_assert.html">CompileAssert&lt;(assertion)&gt;</a> \</div><div class="line">        CRYPTOPP_ASSERT_JOIN(cryptopp_CRYPTOPP_ASSERT_, instance)</div><div class="ttc" id="struct_compile_assert_html"><div class="ttname"><a href="struct_compile_assert.html">CompileAssert</a></div><div class="ttdef"><b>Definition:</b> misc.h:162</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3c5964768bc94670ad2bc3f218d9367f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5964768bc94670ad2bc3f218d9367f">&#9670;&nbsp;</a></span>BitPrecision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int BitPrecision </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bits required for a value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum number of bits required to represent a value. </dd></dl>

</div>
</div>
<a id="a1746e70bf831f0cbf8ad73d8c15bc921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1746e70bf831f0cbf8ad73d8c15bc921">&#9670;&nbsp;</a></span>BitReverse() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte BitReverse </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bits in a 8-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 8-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>BitReverse performs a combination of shifts on the byte </p>

</div>
</div>
<a id="a699c24d7013f20ee03076576984c875e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699c24d7013f20ee03076576984c875e">&#9670;&nbsp;</a></span>BitReverse() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">word16 BitReverse </td>
          <td>(</td>
          <td class="paramtype">word16&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bits in a 16-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 16-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>BitReverse performs a combination of shifts on the word16 </p>

</div>
</div>
<a id="aad87ebeafa7de2c11c19453f3b3cfea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad87ebeafa7de2c11c19453f3b3cfea7">&#9670;&nbsp;</a></span>BitReverse() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">word32 BitReverse </td>
          <td>(</td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bits in a 32-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 32-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>BitReverse performs a combination of shifts on the word32 </p>

</div>
</div>
<a id="a336c0289dcd2670e6b4079fa98018d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336c0289dcd2670e6b4079fa98018d7a">&#9670;&nbsp;</a></span>BitReverse() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">word64 BitReverse </td>
          <td>(</td>
          <td class="paramtype">word64&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bits in a 64-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 64-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>BitReverse performs a combination of shifts on the word64 </p>

</div>
</div>
<a id="a641ecc1d620ac8c04bc43661a2bbba71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641ecc1d620ac8c04bc43661a2bbba71">&#9670;&nbsp;</a></span>BitReverse() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T BitReverse </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bits in a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>The template overload of BitReverse operates on signed and unsigned values. Internally the size of T is checked, and then value is cast to a byte, word16, word32 or word64. After the cast, the appropriate BitReverse overload is called. </p>

</div>
</div>
<a id="a7c5d30b17c9d4869fdc3458dd05c500d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5d30b17c9d4869fdc3458dd05c500d">&#9670;&nbsp;</a></span>BitsToBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BitsToBytes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bitCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of 8-bit bytes or octets required for the specified number of bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitCount</td><td>the number of bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of 8-bit bytes or octets required by bitCount</dd></dl>
<p>BitsToBytes is effectively a ceiling function based on 8-bit bytes. </p>

</div>
</div>
<a id="a778d13f3d45915e1bc5c0ab1801ea6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778d13f3d45915e1bc5c0ab1801ea6ad">&#9670;&nbsp;</a></span>BitsToDwords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BitsToDwords </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bitCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of double words required for the specified number of bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitCount</td><td>the number of bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of double words required by bitCount</dd></dl>
<p>BitsToDwords is effectively a ceiling function based on <code>2*WORD_BITS</code>. <code>WORD_BITS</code> is defined in config.h </p>

</div>
</div>
<a id="a45c56601a8c94b6a37a21657929fe928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c56601a8c94b6a37a21657929fe928">&#9670;&nbsp;</a></span>BitsToWords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BitsToWords </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bitCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of words required for the specified number of bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitCount</td><td>the number of bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of words required by bitCount</dd></dl>
<p>BitsToWords is effectively a ceiling function based on <code>WORD_BITS</code>. <code>WORD_BITS</code> is defined in config.h </p>

</div>
</div>
<a id="a3e22fbd4b8f95aa01bde93ea32e44e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e22fbd4b8f95aa01bde93ea32e44e82">&#9670;&nbsp;</a></span>BytePrecision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int BytePrecision </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of 8-bit bytes or octets required for a value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of 8-bit bytes or octets required to represent a value </dd></dl>

</div>
</div>
<a id="a1d8d5adca8384ebedc699760ce217b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8d5adca8384ebedc699760ce217b08">&#9670;&nbsp;</a></span>ByteReverse() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte ByteReverse </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bytes in a 8-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 8-bit value to reverse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>ByteReverse returns the value passed to it since there is nothing to reverse </dd></dl>

</div>
</div>
<a id="aa179e009cf5c74bb431b3c112d7ee444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa179e009cf5c74bb431b3c112d7ee444">&#9670;&nbsp;</a></span>ByteReverse() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">word16 ByteReverse </td>
          <td>(</td>
          <td class="paramtype">word16&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bytes in a 16-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 16-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>ByteReverse calls bswap if available. Otherwise the function performs a 8-bit rotate on the word16 </p>

</div>
</div>
<a id="acf65f4a9edb6224d01e900aa7205a4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf65f4a9edb6224d01e900aa7205a4f4">&#9670;&nbsp;</a></span>ByteReverse() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">word32 ByteReverse </td>
          <td>(</td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bytes in a 32-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 32-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>ByteReverse calls bswap if available. Otherwise the function uses a combination of rotates on the word32 </p>

</div>
</div>
<a id="a47686f3b4957541a58a3b280d1a89d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47686f3b4957541a58a3b280d1a89d4c">&#9670;&nbsp;</a></span>ByteReverse() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">word64 ByteReverse </td>
          <td>(</td>
          <td class="paramtype">word64&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bytes in a 64-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 64-bit value to reverse</td></tr>
  </table>
  </dd>
</dl>
<p>ByteReverse calls bswap if available. Otherwise the function uses a combination of rotates on the word64 </p>

</div>
</div>
<a id="ab95e030e0abd33ea360d75cd9c4c8bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95e030e0abd33ea360d75cd9c4c8bbe">&#9670;&nbsp;</a></span>ByteReverse() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ByteReverse </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses bytes in an element from an array of elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output array of elements </td></tr>
    <tr><td class="paramname">in</td><td>the input array of elements </td></tr>
    <tr><td class="paramname">byteCount</td><td>the total number of bytes in the array</td></tr>
  </table>
  </dd>
</dl>
<p>Internally, ByteReverse visits each element in the in array calls ByteReverse on it, and writes the result to out.</p>
<p>ByteReverse does not process tail byes, or bytes that are <em>not</em> part of a full element. If T is int (and int is 4 bytes), then <code>byteCount = 10</code> means only the first 2 elements or 8 bytes are reversed.</p>
<p>The follwoing program should help illustrate the behavior. </p><pre>vector&lt;word32&gt; v1, v2;</pre><pre>v1.push_back(1);
v1.push_back(2);
v1.push_back(3);
v1.push_back(4);</pre><pre>v2.resize(v1.size());
ByteReverse&lt;word32&gt;(&amp;v2[0], &amp;v1[0], 16);</pre><pre>cout &lt;&lt; "V1: ";
for(unsigned int i = 0; i &lt; v1.size(); i++)
  cout &lt;&lt; std::hex &lt;&lt; v1[i] &lt;&lt; " ";
cout &lt;&lt; endl;</pre><pre>cout &lt;&lt; "V2: ";
for(unsigned int i = 0; i &lt; v2.size(); i++)
  cout &lt;&lt; std::hex &lt;&lt; v2[i] &lt;&lt; " ";
cout &lt;&lt; endl;</pre><p> The program above results in the follwoing output. </p><pre>V1: 00000001 00000002 00000003 00000004
V2: 01000000 02000000 03000000 04000000</pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="misc_8h.html#a8e499ded4f2e7e7705c3cfd39cdf137f" title="Reverses bytes in a value depending upon endianness. ">ConditionalByteReverse</a> </dd></dl>

</div>
</div>
<a id="a886cc7ce76578c6df939f564f676e71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886cc7ce76578c6df939f564f676e71a">&#9670;&nbsp;</a></span>BytesToWords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BytesToWords </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byteCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of words required for the specified number of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byteCount</td><td>the number of bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of words required by byteCount</dd></dl>
<p>BytesToWords is effectively a ceiling function based on <code>WORD_SIZE</code>. <code>WORD_SIZE</code> is defined in config.h </p>

</div>
</div>
<a id="ab0f5dcab97ccb3e9449d487dd37ffc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f5dcab97ccb3e9449d487dd37ffc7a">&#9670;&nbsp;</a></span>CallNewHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CRYPTOPP_DLL void CRYPTOPP_API CallNewHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to reclaim unused memory. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">bad_alloc</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>In the normal course of running a program, a request for memory normally succeeds. If a call to AlignedAllocate or UnalignedAllocate fails, then CallNewHandler is called in an effort to recover. Internally, CallNewHandler calls set_new_handler(NULLPTR) in an effort to free memory. There is no guarantee CallNewHandler will be able to procure more memory so an allocation succeeds. If the call to set_new_handler fails, then CallNewHandler throws a bad_alloc exception. </p>

</div>
</div>
<a id="a8e499ded4f2e7e7705c3cfd39cdf137f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e499ded4f2e7e7705c3cfd39cdf137f">&#9670;&nbsp;</a></span>ConditionalByteReverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T ConditionalByteReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses bytes in a value depending upon endianness. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">value</td><td>the value to conditionally reverse</td></tr>
  </table>
  </dd>
</dl>
<p>Internally, the ConditionalByteReverse calls NativeByteOrderIs. If order matches native byte order, then the original value is returned. If not, then ByteReverse is called on the value before returning to the caller. </p>

</div>
</div>
<a id="aae0de65c1758668440f71a8ff6534ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0de65c1758668440f71a8ff6534ad9">&#9670;&nbsp;</a></span>ConditionalByteReverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConditionalByteReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally reverses bytes in an element from an array of elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">out</td><td>the output array of elements </td></tr>
    <tr><td class="paramname">in</td><td>the input array of elements </td></tr>
    <tr><td class="paramname">byteCount</td><td>the byte count of the arrays</td></tr>
  </table>
  </dd>
</dl>
<p>Internally, ByteReverse visits each element in the in array calls ByteReverse on it depending on the desired endianness, and writes the result to out.</p>
<p>ByteReverse does not process tail byes, or bytes that are <em>not</em> part of a full element. If T is int (and int is 4 bytes), then <code>byteCount = 10</code> means only the first 2 elements or 8 bytes are reversed. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="misc_8h.html#a1d8d5adca8384ebedc699760ce217b08" title="Reverses bytes in a 8-bit value. ">ByteReverse</a> </dd></dl>

</div>
</div>
<a id="ae71e5659910553da22f9b1e877cddc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71e5659910553da22f9b1e877cddc07">&#9670;&nbsp;</a></span>ConditionalSwap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConditionalSwap </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a branchless swap of values a and b if condition c is true. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the condition to perform the swap </td></tr>
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a513e4522b268f9ee2e188606c2101d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513e4522b268f9ee2e188606c2101d5a">&#9670;&nbsp;</a></span>ConditionalSwapPointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConditionalSwapPointers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a branchless swap of pointers a and b if condition c is true. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the condition to perform the swap </td></tr>
    <tr><td class="paramname">a</td><td>the first pointer </td></tr>
    <tr><td class="paramname">b</td><td>the second pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a616a7f0365c4947b0c8a44606c525a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616a7f0365c4947b0c8a44606c525a62">&#9670;&nbsp;</a></span>Crop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Crop </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncates the value to the specified number of bits. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to truncate or mask </td></tr>
    <tr><td class="paramname">bits</td><td>the number of bits to truncate or mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value truncated to the specified number of bits, starting at the least significant bit position</dd></dl>
<p>This function masks the low-order bits of value and returns the result. The mask is created with <code>(1 &lt;&lt; bits) - 1</code>. </p>

</div>
</div>
<a id="ab4e438054095c88f0c4d9eda7efc584d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e438054095c88f0c4d9eda7efc584d">&#9670;&nbsp;</a></span>GetAlignmentOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GetAlignmentOf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum alignment requirements of a type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum alignment requirements of <code>T</code>, in bytes</dd></dl>
<p>Internally the function calls C++11's <code>alignof</code> if available. If not available, then the function uses compiler specific extensions such as <code>__alignof</code> and <code>_alignof_</code>. If an extension is not available, then the function uses <code>__BIGGEST_ALIGNMENT__</code> if <code>__BIGGEST_ALIGNMENT__</code> is smaller than <code>sizeof(T)</code>. <code>sizeof(T)</code> is used if all others are not available. In <em>all</em> cases, if <code>CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS</code> is defined, then the function returns 1. </p>

</div>
</div>
<a id="a9a2ceb73851e757cb436cdbaa0242219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2ceb73851e757cb436cdbaa0242219">&#9670;&nbsp;</a></span>GetByte()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GetByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a byte from a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ByteOrder of the value </td></tr>
    <tr><td class="paramname">value</td><td>the value to retrieve the byte </td></tr>
    <tr><td class="paramname">index</td><td>the location of the byte to retrieve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade22f7ed542b3db2912c917f8e3d6067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade22f7ed542b3db2912c917f8e3d6067">&#9670;&nbsp;</a></span>GetCipherDir()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cryptlib_8h.html#a353ccabf5ddc119a6a33e92f7b9961c7">CipherDir</a> GetCipherDir </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the direction the cipher is being operated. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the cipher object being queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>ENCRYPTION</code> if the cipher obj is being operated in its forward direction, <code>DECRYPTION</code> otherwise</dd></dl>
<p>A cipher can be operated in a "forward" direction (encryption) or a "reverse" direction (decryption). The operations do not have to be symmetric, meaning a second application of the transformation does not necessariy return the original message. That is, <code>E(D(m))</code> may not equal <code>E(E(m))</code>; and <code>D(E(m))</code> may not equal <code>D(D(m))</code>. </p>

</div>
</div>
<a id="aed8336b0d98f2469441837be6cbbebf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8336b0d98f2469441837be6cbbebf9">&#9670;&nbsp;</a></span>GetNativeByteOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> GetNativeByteOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns NativeByteOrder as an enumerated ByteOrder value. </p>
<dl class="section return"><dt>Returns</dt><dd>LittleEndian if the native byte order is little-endian, and BigEndian if the native byte order is big-endian</dd></dl>
<p>NativeByteOrder is a typedef depending on the platform. If IS_LITTLE_ENDIAN is set in config.h, then GetNativeByteOrder returns LittleEndian. If IS_BIG_ENDIAN is set, then GetNativeByteOrder returns BigEndian. </p><dl class="section note"><dt>Note</dt><dd>There are other byte orders besides little- and big-endian, and they include bi-endian and PDP-endian. If a system is neither little-endian nor big-endian, then a compile time error occurs. </dd></dl>

</div>
</div>
<a id="a240e8e97f964626508362b59b78532d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240e8e97f964626508362b59b78532d3">&#9670;&nbsp;</a></span>GetWord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T GetWord </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>assumeAligned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a block of memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assumeAligned</td><td>flag indicating alignment </td></tr>
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">block</td><td>the byte buffer to be processed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the word in the specified byte order</dd></dl>
<p><a class="el" href="misc_8h.html#a240e8e97f964626508362b59b78532d3" title="Access a block of memory. ">GetWord()</a> provides alternate read access to a block of memory. The flag assumeAligned indicates if the memory block is aligned for class or type T. The enumeration ByteOrder is BIG_ENDIAN_ORDER or LITTLE_ENDIAN_ORDER.</p>
<p>An example of reading two word32 values from a block of memory is shown below. <code>w</code> will be <code>0x03020100</code>. </p><pre>
   word32 w;
   byte buffer[4] = {0,1,2,3};
   w = GetWord&lt;word32&gt;(false, LITTLE_ENDIAN_ORDER, buffer);
</pre> 
</div>
</div>
<a id="a4546cdeeecddedd3a0f784ea6b80c8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4546cdeeecddedd3a0f784ea6b80c8bd">&#9670;&nbsp;</a></span>GetWord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GetWord </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>assumeAligned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a block of memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assumeAligned</td><td>flag indicating alignment </td></tr>
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">result</td><td>the word in the specified byte order </td></tr>
    <tr><td class="paramname">block</td><td>the byte buffer to be processed</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="misc_8h.html#a240e8e97f964626508362b59b78532d3" title="Access a block of memory. ">GetWord()</a> provides alternate read access to a block of memory. The flag assumeAligned indicates if the memory block is aligned for class or type T. The enumeration ByteOrder is BIG_ENDIAN_ORDER or LITTLE_ENDIAN_ORDER.</p>
<p>An example of reading two word32 values from a block of memory is shown below. <code>w</code> will be <code>0x03020100</code>. </p><pre>
   word32 w;
   byte buffer[4] = {0,1,2,3};
   w = GetWord&lt;word32&gt;(false, LITTLE_ENDIAN_ORDER, buffer);
</pre> 
</div>
</div>
<a id="a44fad9d8c25e8aca3a7ee29345516f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fad9d8c25e8aca3a7ee29345516f0a">&#9670;&nbsp;</a></span>IncrementCounterByOne() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IncrementCounterByOne </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>inout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an addition with carry on a block of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inout</td><td>the byte block </td></tr>
    <tr><td class="paramname">size</td><td>the size of the block, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Performs an addition with carry by adding 1 on a block of bytes starting at the least significant byte. Once carry is 0, the function terminates and returns to the caller. </p><dl class="section note"><dt>Note</dt><dd>The function is not constant time because it stops processing when the carry is 0. </dd></dl>

</div>
</div>
<a id="a2f852960b51e106a849781341cb2055c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f852960b51e106a849781341cb2055c">&#9670;&nbsp;</a></span>IncrementCounterByOne() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IncrementCounterByOne </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an addition with carry on a block of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>the destination block of bytes </td></tr>
    <tr><td class="paramname">input</td><td>the source block of bytes </td></tr>
    <tr><td class="paramname">size</td><td>the size of the block</td></tr>
  </table>
  </dd>
</dl>
<p>Performs an addition with carry on a block of bytes starting at the least significant byte. Once carry is 0, the remaining bytes from input are copied to output using memcpy.</p>
<p>The function is <em>close</em> to near-constant time because it operates on all the bytes in the blocks. </p>

</div>
</div>
<a id="a6cd7decd035cc4e144cd3d395e834106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd7decd035cc4e144cd3d395e834106">&#9670;&nbsp;</a></span>IntToString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string IntToString </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a value to a string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to convert </td></tr>
    <tr><td class="paramname">base</td><td>the base to use during the conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string representation of value in base. </dd></dl>

</div>
</div>
<a id="a1b67e971e2ab82125e3cf2a08a24a103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b67e971e2ab82125e3cf2a08a24a103">&#9670;&nbsp;</a></span>IntToString&lt; Integer &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CRYPTOPP_DLL std::string <a class="el" href="misc_8h.html#a6cd7decd035cc4e144cd3d395e834106">IntToString</a>&lt; <a class="el" href="class_integer.html">Integer</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_integer.html">Integer</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <a class="el" href="class_integer.html" title="Multiple precision integer with arithmetic operations. ">Integer</a> to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the <a class="el" href="class_integer.html" title="Multiple precision integer with arithmetic operations. ">Integer</a> to convert </td></tr>
    <tr><td class="paramname">base</td><td>the base to use during the conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string representation of value in base.</dd></dl>
<p>This is a template specialization of <a class="el" href="misc_8h.html#a6cd7decd035cc4e144cd3d395e834106" title="Converts a value to a string. ">IntToString()</a>. Use it like <a class="el" href="misc_8h.html#a6cd7decd035cc4e144cd3d395e834106" title="Converts a value to a string. ">IntToString()</a>: </p><pre>
  // Print integer in base 10
  <a class="el" href="class_integer.html" title="Multiple precision integer with arithmetic operations. ">Integer</a> n...
  std::string s = IntToString(n, 10);
</pre><p>The string is presented with lowercase letters by default. A hack is available to switch to uppercase letters without modifying the function signature. </p><pre>
  // Print integer in base 16, uppercase letters
  <a class="el" href="class_integer.html" title="Multiple precision integer with arithmetic operations. ">Integer</a> n...
  const unsigned int UPPER = (1 &lt;&lt; 31);
  std::string s = IntToString(n, (UPPER | 16));</pre> 
</div>
</div>
<a id="aad4f4608b867f01a4cad90c5b222f89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4f4608b867f01a4cad90c5b222f89b">&#9670;&nbsp;</a></span>IntToString&lt; word64 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CRYPTOPP_DLL std::string <a class="el" href="misc_8h.html#a6cd7decd035cc4e144cd3d395e834106">IntToString</a>&lt; word64 &gt; </td>
          <td>(</td>
          <td class="paramtype">word64&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an unsigned value to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to convert </td></tr>
    <tr><td class="paramname">base</td><td>the base to use during the conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string representation of value in base.</dd></dl>
<p>this template function specialization was added to suppress Coverity findings on <a class="el" href="misc_8h.html#a6cd7decd035cc4e144cd3d395e834106" title="Converts a value to a string. ">IntToString()</a> with unsigned types. </p>

</div>
</div>
<a id="a8b2c95659d16a971941622625c9102ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2c95659d16a971941622625c9102ae">&#9670;&nbsp;</a></span>IsAligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsAligned </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether ptr is minimally aligned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer to check for alignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>ptr</code> is aligned to at least <code>T</code> boundary, false otherwise</dd></dl>
<p>Internally the function calls IsAlignedOn with a second parameter of GetAlignmentOf&lt;T&gt; </p>

</div>
</div>
<a id="a726c3b76265182681f5d5fd173ab5676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726c3b76265182681f5d5fd173ab5676">&#9670;&nbsp;</a></span>IsAlignedOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsAlignedOn </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether ptr is aligned to a minimum value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer being checked for alignment </td></tr>
    <tr><td class="paramname">alignment</td><td>the alignment value to test the pointer against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>ptr</code> is aligned on at least <code>alignment</code> boundary, false otherwise</dd></dl>
<p>Internally the function tests whether alignment is 1. If so, the function returns true. If not, then the function effectively performs a modular reduction and returns true if the residue is 0 </p>

</div>
</div>
<a id="a65531618a7eca8803fa9e9287c43aafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65531618a7eca8803fa9e9287c43aafc">&#9670;&nbsp;</a></span>IsPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether a value is a power of 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value is a power of 2, false otherwise</dd></dl>
<p>The function creates a mask of <code>value - 1</code> and returns the result of an AND operation compared to 0. If value is 0 or less than 0, then the function returns false. </p>

</div>
</div>
<a id="a5f6fcbaaf6f72fe46a6d911b033dfea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6fcbaaf6f72fe46a6d911b033dfea0">&#9670;&nbsp;</a></span>memcpy_s()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void memcpy_s </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bounds checking replacement for memcpy() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to the desination memory block </td></tr>
    <tr><td class="paramname">sizeInBytes</td><td>the size of the desination memory block, in bytes </td></tr>
    <tr><td class="paramname">src</td><td>pointer to the source memory block </td></tr>
    <tr><td class="paramname">count</td><td>the size of the source memory block, in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_invalid_argument.html" title="An invalid argument was detected. ">InvalidArgument</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<p>ISO/IEC TR-24772 provides bounds checking interfaces for potentially unsafe functions like memcpy(), strcpy() and memmove(). However, not all standard libraries provides them, like Glibc. The library's <a class="el" href="misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0" title="Bounds checking replacement for memcpy() ">memcpy_s()</a> is a near-drop in replacement. Its only a near-replacement because the library's version throws an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected. ">InvalidArgument</a> on a bounds violation.</p>
<p><a class="el" href="misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0" title="Bounds checking replacement for memcpy() ">memcpy_s()</a> and <a class="el" href="misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de" title="Bounds checking replacement for memmove() ">memmove_s()</a> are guarded by <b>STDC_WANT_SECURE_LIB</b>. If <b>STDC_WANT_SECURE_LIB</b> is <em>not</em> defined or defined to 0, then the library makes <a class="el" href="misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0" title="Bounds checking replacement for memcpy() ">memcpy_s()</a> and <a class="el" href="misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de" title="Bounds checking replacement for memmove() ">memmove_s()</a> available. The library will also optionally make the symbols available if <code>CRYPTOPP_WANT_SECURE_LIB</code> is defined. <code>CRYPTOPP_WANT_SECURE_LIB</code> is in config.h, but it is disabled by default.</p>
<p><a class="el" href="misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0" title="Bounds checking replacement for memcpy() ">memcpy_s()</a> will assert the pointers src and dest are not NULL in debug builds. Passing NULL for either pointer is undefined behavior. </p>

</div>
</div>
<a id="adb296eab4ca31ab5c0cf4a932488a8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb296eab4ca31ab5c0cf4a932488a8de">&#9670;&nbsp;</a></span>memmove_s()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void memmove_s </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bounds checking replacement for memmove() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to the desination memory block </td></tr>
    <tr><td class="paramname">sizeInBytes</td><td>the size of the desination memory block, in bytes </td></tr>
    <tr><td class="paramname">src</td><td>pointer to the source memory block </td></tr>
    <tr><td class="paramname">count</td><td>the size of the source memory block, in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_invalid_argument.html" title="An invalid argument was detected. ">InvalidArgument</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<p>ISO/IEC TR-24772 provides bounds checking interfaces for potentially unsafe functions like memcpy(), strcpy() and memmove(). However, not all standard libraries provides them, like Glibc. The library's <a class="el" href="misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de" title="Bounds checking replacement for memmove() ">memmove_s()</a> is a near-drop in replacement. Its only a near-replacement because the library's version throws an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected. ">InvalidArgument</a> on a bounds violation.</p>
<p><a class="el" href="misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0" title="Bounds checking replacement for memcpy() ">memcpy_s()</a> and <a class="el" href="misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de" title="Bounds checking replacement for memmove() ">memmove_s()</a> are guarded by <b>STDC_WANT_SECURE_LIB</b>. If <b>STDC_WANT_SECURE_LIB</b> is <em>not</em> defined or defined to 0, then the library makes <a class="el" href="misc_8h.html#a5f6fcbaaf6f72fe46a6d911b033dfea0" title="Bounds checking replacement for memcpy() ">memcpy_s()</a> and <a class="el" href="misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de" title="Bounds checking replacement for memmove() ">memmove_s()</a> available. The library will also optionally make the symbols available if <code>CRYPTOPP_WANT_SECURE_LIB</code> is defined. <code>CRYPTOPP_WANT_SECURE_LIB</code> is in config.h, but it is disabled by default.</p>
<p><a class="el" href="misc_8h.html#adb296eab4ca31ab5c0cf4a932488a8de" title="Bounds checking replacement for memmove() ">memmove_s()</a> will assert the pointers src and dest are not NULL in debug builds. Passing NULL for either pointer is undefined behavior. </p>

</div>
</div>
<a id="ab8804f66768d757773489cde7738df1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8804f66768d757773489cde7738df1e">&#9670;&nbsp;</a></span>memset_z()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* memset_z </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memory block initializer and eraser that attempts to survive optimizations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer to the memory block being written </td></tr>
    <tr><td class="paramname">value</td><td>the integer value to write for each byte </td></tr>
    <tr><td class="paramname">num</td><td>the size of the source memory block, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Internally the function calls memset with the value value, and receives the return value from memset as a <code>volatile</code> pointer. </p>

</div>
</div>
<a id="a621695f6346d6a745e340513d917b31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621695f6346d6a745e340513d917b31a">&#9670;&nbsp;</a></span>ModPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 ModPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduces a value to a power of 2. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="misc_8h.html#a621695f6346d6a745e340513d917b31a" title="Reduces a value to a power of 2. ">ModPowerOf2()</a> returns <code>a &amp; (b-1)</code>. <code>b</code> must be a power of 2. Use <a class="el" href="misc_8h.html#a65531618a7eca8803fa9e9287c43aafc" title="Tests whether a value is a power of 2. ">IsPowerOf2()</a> to determine if <code>b</code> is a suitable candidate. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="misc_8h.html#a65531618a7eca8803fa9e9287c43aafc" title="Tests whether a value is a power of 2. ">IsPowerOf2</a> </dd></dl>

</div>
</div>
<a id="a6c2da0dd866619761e63c3b5da58c477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2da0dd866619761e63c3b5da58c477">&#9670;&nbsp;</a></span>NativeByteOrderIs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NativeByteOrderIs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether order follows native byte ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the ordering being tested against native byte ordering </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if order follows native byte ordering, false otherwise </dd></dl>

</div>
</div>
<a id="a6c63a5683602db0ff8975746a414797f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c63a5683602db0ff8975746a414797f">&#9670;&nbsp;</a></span>Parity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Parity </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the parity of a value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to provide the parity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the number 1-bits in the value is odd, 0 otherwise </dd></dl>

</div>
</div>
<a id="a096e90ab9bb746edf908d25f0856a786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096e90ab9bb746edf908d25f0856a786">&#9670;&nbsp;</a></span>PutWord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PutWord </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>assumeAligned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>xorBlock</em> = <code>NULLPTR</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a block of memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assumeAligned</td><td>flag indicating alignment </td></tr>
    <tr><td class="paramname">order</td><td>the ByteOrder of the data </td></tr>
    <tr><td class="paramname">block</td><td>the destination byte buffer </td></tr>
    <tr><td class="paramname">value</td><td>the word in the specified byte order </td></tr>
    <tr><td class="paramname">xorBlock</td><td>an optional byte buffer to xor</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="misc_8h.html#a096e90ab9bb746edf908d25f0856a786" title="Access a block of memory. ">PutWord()</a> provides alternate write access to a block of memory. The flag assumeAligned indicates if the memory block is aligned for class or type T. The enumeration ByteOrder is BIG_ENDIAN_ORDER or LITTLE_ENDIAN_ORDER. </p>

</div>
</div>
<a id="aaf7b80a08d25ab9d62693c9e4798ef98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7b80a08d25ab9d62693c9e4798ef98">&#9670;&nbsp;</a></span>rotlFixed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotlFixed </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a left rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate </td></tr>
    <tr><td class="paramname">y</td><td>the number of bit positions to rotate the value</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>y must be in the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. Use rotlMod if the rotate amount y is outside the range. </p><dl class="section note"><dt>Note</dt><dd>rotlFixed attempts to enlist a <code>rotate IMM</code> instruction because its often faster than a <code>rotate REG</code>. Immediate rotates can be up to three times faster than their register counterparts. </dd></dl>

</div>
</div>
<a id="ad31fe5d559d014085c6a49594b817196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31fe5d559d014085c6a49594b817196">&#9670;&nbsp;</a></span>rotlMod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotlMod </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a left rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate </td></tr>
    <tr><td class="paramname">y</td><td>the number of bit positions to rotate the value</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>y is reduced to the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. </p><dl class="section note"><dt>Note</dt><dd>rotrVariable will use either <code>rotate IMM</code> or <code>rotate REG</code>. </dd></dl>

</div>
</div>
<a id="a0de05253683b27a221e6465b3a7453b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de05253683b27a221e6465b3a7453b2">&#9670;&nbsp;</a></span>rotlVariable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotlVariable </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a left rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate </td></tr>
    <tr><td class="paramname">y</td><td>the number of bit positions to rotate the value</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>y must be in the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. Use rotlMod if the rotate amount y is outside the range. </p><dl class="section note"><dt>Note</dt><dd>rotlVariable attempts to enlist a <code>rotate IMM</code> instruction because its often faster than a <code>rotate REG</code>. Immediate rotates can be up to three times faster than their register counterparts. </dd></dl>

</div>
</div>
<a id="abf88e95400925b89c94641916535b6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf88e95400925b89c94641916535b6da">&#9670;&nbsp;</a></span>rotrFixed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotrFixed </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a right rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate </td></tr>
    <tr><td class="paramname">y</td><td>the number of bit positions to rotate the value</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>y must be in the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. Use rotrMod if the rotate amount y is outside the range. </p><dl class="section note"><dt>Note</dt><dd>rotrFixed attempts to enlist a <code>rotate IMM</code> instruction because its often faster than a <code>rotate REG</code>. Immediate rotates can be up to three times faster than their register counterparts. </dd></dl>

</div>
</div>
<a id="ae8fc34eb834dd2424407d5e4d729594e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fc34eb834dd2424407d5e4d729594e">&#9670;&nbsp;</a></span>rotrMod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotrMod </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a right rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate </td></tr>
    <tr><td class="paramname">y</td><td>the number of bit positions to rotate the value</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>y is reduced to the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. </p><dl class="section note"><dt>Note</dt><dd>rotrVariable will use either <code>rotate IMM</code> or <code>rotate REG</code>. </dd></dl>

</div>
</div>
<a id="abd053d245fe902fe55bfd8a335634110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd053d245fe902fe55bfd8a335634110">&#9670;&nbsp;</a></span>rotrVariable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T rotrVariable </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a right rotate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the word type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate </td></tr>
    <tr><td class="paramname">y</td><td>the number of bit positions to rotate the value</td></tr>
  </table>
  </dd>
</dl>
<p>This is a portable C/C++ implementation. The value x to be rotated can be 8 to 64-bits wide.</p>
<p>y must be in the range <code>[0, sizeof(T)*8 - 1]</code> to avoid undefined behavior. Use rotrMod if the rotate amount y is outside the range. </p><dl class="section note"><dt>Note</dt><dd>rotrVariable attempts to enlist a <code>rotate IMM</code> instruction because its often faster than a <code>rotate REG</code>. Immediate rotates can be up to three times faster than their register counterparts. </dd></dl>

</div>
</div>
<a id="aa2ac57210cb6796eced074e6d2e294fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ac57210cb6796eced074e6d2e294fb">&#9670;&nbsp;</a></span>RoundDownToMultipleOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 RoundDownToMultipleOf </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds a value down to a multiple of a second value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the value to reduce </td></tr>
    <tr><td class="paramname">m</td><td>the value to reduce <br />
 to to a multiple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the possibly unmodified value <br />
</dd></dl>
<p>RoundDownToMultipleOf is effectively a floor function based on m. The function returns the value <code>n - n%m</code>. If n is a multiple of m, then the original value is returned. </p><dl class="section note"><dt>Note</dt><dd><code>T1</code> and <code>T2</code> should be usigned arithmetic types. If <code>T1</code> or <code>T2</code> is signed, then the value should be non-negative. The library asserts in debug builds when practical, but allows you to perform the operation in release builds. </dd></dl>

</div>
</div>
<a id="a57a219d44f45272a1f3b3f17a656000a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a219d44f45272a1f3b3f17a656000a">&#9670;&nbsp;</a></span>RoundUpToMultipleOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 RoundUpToMultipleOf </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds a value up to a multiple of a second value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the value to reduce </td></tr>
    <tr><td class="paramname">m</td><td>the value to reduce <br />
 to to a multiple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the possibly unmodified value <br />
</dd></dl>
<p>RoundUpToMultipleOf is effectively a ceiling function based on m. The function returns the value <code>n + n%m</code>. If n is a multiple of m, then the original value is returned. If the value n would overflow, then an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected. ">InvalidArgument</a> exception is thrown. </p><dl class="section note"><dt>Note</dt><dd><code>T1</code> and <code>T2</code> should be usigned arithmetic types. If <code>T1</code> or <code>T2</code> is signed, then the value should be non-negative. The library asserts in debug builds when practical, but allows you to perform the operation in release builds. </dd></dl>

</div>
</div>
<a id="a8a2ce94589bb74164d809f4675bd23dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2ce94589bb74164d809f4675bd23dd">&#9670;&nbsp;</a></span>SafeConvert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SafeConvert </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether a conversion from -&gt; to is safe to perform. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first value </td></tr>
    <tr><td class="paramname">to</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if its safe to convert from into to, false otherwise. </dd></dl>

</div>
</div>
<a id="a45e2662974095094e345b2bc2b30ee4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e2662974095094e345b2bc2b30ee4c">&#9670;&nbsp;</a></span>SafeLeftShift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int bits, class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SafeLeftShift </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely left shift values when undefined behavior could occur. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bits</td><td>the number of bit positions to shift the value </td></tr>
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to left shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shifted value or 0</dd></dl>
<p>SafeLeftShift safely shifts the value to the left when undefined behavior could occur under C/C++ rules. SafeLeftShift will return the shifted value or 0 if undefined behavior would occur. </p>

</div>
</div>
<a id="abda5071e4c754b612b6a4c42be421312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda5071e4c754b612b6a4c42be421312">&#9670;&nbsp;</a></span>SafeRightShift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int bits, class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SafeRightShift </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely right shift values when undefined behavior could occur. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bits</td><td>the number of bit positions to shift the value </td></tr>
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to right shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shifted value or 0</dd></dl>
<p>SafeRightShift safely shifts the value to the right when undefined behavior could occur under C/C++ rules. SafeRightShift will return the shifted value or 0 if undefined behavior would occur. </p>

</div>
</div>
<a id="a30712a90999ad9d9152975f2e92d46b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30712a90999ad9d9152975f2e92d46b8">&#9670;&nbsp;</a></span>SaturatingSubtract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 SaturatingSubtract </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a saturating subtract clamped at 0. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the minuend </td></tr>
    <tr><td class="paramname">b</td><td>the subtrahend </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference produced by the saturating subtract</dd></dl>
<p>Saturating arithmetic restricts results to a fixed range. Results that are less than 0 are clamped at 0.</p>
<p>Use of saturating arithmetic in places can be advantageous because it can avoid a branch by using an instruction like a conditional move (<code>CMOVE</code>). </p>

</div>
</div>
<a id="afd39d67faef904dbb474981762b7ebe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd39d67faef904dbb474981762b7ebe1">&#9670;&nbsp;</a></span>SaturatingSubtract1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 SaturatingSubtract1 </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a saturating subtract clamped at 1. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the minuend </td></tr>
    <tr><td class="paramname">b</td><td>the subtrahend </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference produced by the saturating subtract</dd></dl>
<p>Saturating arithmetic restricts results to a fixed range. Results that are less than 1 are clamped at 1.</p>
<p>Use of saturating arithmetic in places can be advantageous because it can avoid a branch by using an instruction like a conditional move (<code>CMOVE</code>). </p>

</div>
</div>
<a id="a4994f3480634e5f1435fd71f9b652c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4994f3480634e5f1435fd71f9b652c38">&#9670;&nbsp;</a></span>SecureWipeArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SecureWipeArray </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets each element of an array to 0. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>an array of elements </td></tr>
    <tr><td class="paramname">n</td><td>the number of elements in the array</td></tr>
  </table>
  </dd>
</dl>
<p>The operation performs a wipe or zeroization. The function attempts to survive optimizations and dead code removal. </p>

</div>
</div>
<a id="a656f38b8d0440981f5f013ada782018c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656f38b8d0440981f5f013ada782018c">&#9670;&nbsp;</a></span>SecureWipeBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SecureWipeBuffer </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets each element of an array to 0. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>an array of elements </td></tr>
    <tr><td class="paramname">n</td><td>the number of elements in the array</td></tr>
  </table>
  </dd>
</dl>
<p>The operation performs a wipe or zeroization. The function attempts to survive optimizations and dead code removal </p>

</div>
</div>
<a id="af1490597cb11989e78d5ba5b5f21266b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1490597cb11989e78d5ba5b5f21266b">&#9670;&nbsp;</a></span>STDMAX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; STDMAX </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replacement function for std::max. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum value based on a comparison of <code>a &lt; b</code> using <code>operator&lt;</code></dd></dl>
<p>STDMAX was provided because the library could not easily use std::min or std::max in Windows or Cygwin 1.1.0 </p>

</div>
</div>
<a id="abe412b0409249cb54899e97bc7d86424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe412b0409249cb54899e97bc7d86424">&#9670;&nbsp;</a></span>STDMIN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; STDMIN </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replacement function for std::min. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum value based on a comparison of <code>b &lt; a</code> using <code>operator&lt;</code></dd></dl>
<p>STDMIN was provided because the library could not easily use std::min or std::max in Windows or Cygwin 1.1.0 </p>

</div>
</div>
<a id="aba2ed56f8a15d6dabbef74390eda4352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2ed56f8a15d6dabbef74390eda4352">&#9670;&nbsp;</a></span>StringNarrow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string StringNarrow </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>throwOnError</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a wide character C-string to a multibyte string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string consisting of wide characters </td></tr>
    <tr><td class="paramname">throwOnError</td><td>flag indicating the function should throw on error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>str converted to a multibyte string or an empty string.</dd></dl>
<p><a class="el" href="misc_8h.html#aba2ed56f8a15d6dabbef74390eda4352" title="Converts a wide character C-string to a multibyte string. ">StringNarrow()</a> converts a wide string to a narrow string using C++ std::wcstombs() under the executing thread's locale. A locale must be set before using this function, and it can be set with std::setlocale() if needed. Upon success, the converted string is returned.</p>
<p>Upon failure with throwOnError as false, the function returns an empty string. If throwOnError as true, the function throws an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected. ">InvalidArgument()</a> exception. </p><dl class="section note"><dt>Note</dt><dd>If you try to convert, say, the Chinese character for "bone" from UTF-16 (0x9AA8) to UTF-8 (0xE9 0xAA 0xA8), then you must ensure the locale is available. If the locale is not available, then a 0x21 error is returned on Windows which eventually results in an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected. ">InvalidArgument()</a> exception. </dd></dl>

</div>
</div>
<a id="ac95ff706a83782e3d18a3d14817db932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95ff706a83782e3d18a3d14817db932">&#9670;&nbsp;</a></span>StringWiden()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring StringWiden </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>throwOnError</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a multibyte C-string to a wide character string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string consisting of wide characters </td></tr>
    <tr><td class="paramname">throwOnError</td><td>flag indicating the function should throw on error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>str converted to a multibyte string or an empty string.</dd></dl>
<p><a class="el" href="misc_8h.html#ac95ff706a83782e3d18a3d14817db932" title="Converts a multibyte C-string to a wide character string. ">StringWiden()</a> converts a narrow string to a wide string using C++ std::mbstowcs() under the executing thread's locale. A locale must be set before using this function, and it can be set with std::setlocale() if needed. Upon success, the converted string is returned.</p>
<p>Upon failure with throwOnError as false, the function returns an empty string. If throwOnError as true, the function throws an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected. ">InvalidArgument()</a> exception. </p><dl class="section note"><dt>Note</dt><dd>If you try to convert, say, the Chinese character for "bone" from UTF-8 (0xE9 0xAA 0xA8) to UTF-16 (0x9AA8), then you must ensure the locale is available. If the locale is not available, then a 0x21 error is returned on Windows which eventually results in an <a class="el" href="class_invalid_argument.html" title="An invalid argument was detected. ">InvalidArgument()</a> exception. </dd></dl>

</div>
</div>
<a id="a495acbd6f3cdabbb4dd863c09b378df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495acbd6f3cdabbb4dd863c09b378df4">&#9670;&nbsp;</a></span>TrailingZeros() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TrailingZeros </td>
          <td>(</td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the number of trailing 0-bits in a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the 32-bit value to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of trailing 0-bits in v, starting at the least significant bit position</dd></dl>
<p>TrailingZeros returns the number of trailing 0-bits in v, starting at the least significant bit position. The return value is undefined if there are no 1-bits set in the value v. </p><dl class="section note"><dt>Note</dt><dd>The function does <em>not</em> return 0 if no 1-bits are set because 0 collides with a 1-bit at the 0-th position. </dd></dl>

</div>
</div>
<a id="addb4df9b2f1e119d89a1573338c4eda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb4df9b2f1e119d89a1573338c4eda6">&#9670;&nbsp;</a></span>TrailingZeros() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TrailingZeros </td>
          <td>(</td>
          <td class="paramtype">word64&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the number of trailing 0-bits in a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the 64-bit value to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of trailing 0-bits in v, starting at the least significant bit position</dd></dl>
<p>TrailingZeros returns the number of trailing 0-bits in v, starting at the least significant bit position. The return value is undefined if there are no 1-bits set in the value v. </p><dl class="section note"><dt>Note</dt><dd>The function does <em>not</em> return 0 if no 1-bits are set because 0 collides with a 1-bit at the 0-th position. </dd></dl>

</div>
</div>
<a id="acf0175d502d0936c6692e39fc976a294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0175d502d0936c6692e39fc976a294">&#9670;&nbsp;</a></span>UnalignedAllocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CRYPTOPP_DLL void* CRYPTOPP_API UnalignedAllocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the size of the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55427b31e548a01ab518279b60cee025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55427b31e548a01ab518279b60cee025">&#9670;&nbsp;</a></span>UnalignedDeallocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CRYPTOPP_DLL void CRYPTOPP_API UnalignedDeallocate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a buffer allocated with UnalignedAllocate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the buffer to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8391e7d9d613a6c401787d2cdab1f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8391e7d9d613a6c401787d2cdab1f51">&#9670;&nbsp;</a></span>UnsignedMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T1 UnsignedMin </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safe comparison of values that could be neagtive and incorrectly promoted. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>class or type </td></tr>
    <tr><td class="paramname">T2</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum value based on a comparison a and b using <code>operator&lt;</code>.</dd></dl>
<p>The comparison <code>b &lt; a</code> is performed and the value returned is a's type T1. </p>

</div>
</div>
<a id="a810542d642def73fd278c08092417e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810542d642def73fd278c08092417e11">&#9670;&nbsp;</a></span>vec_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vec_swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two variables which are arrays. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>class or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value</td></tr>
  </table>
  </dd>
</dl>
<p>C++03 does not provide support for <code>std::swap(__m128i a, __m128i b)</code> because <code>__m128i</code> is an <code>unsigned long long[2]</code>. Most compilers support it out of the box, but Sun Studio C++ compilers 12.2 and 12.3 do not. </p><dl class="section see"><dt>See also</dt><dd><a href="http://stackoverflow.com/q/38417413">How to swap two __m128i variables in C++03 given its an opaque type and an array?</a> on Stack Overflow. </dd></dl>

</div>
</div>
<a id="a9f1c626f8d491a96c517b5a165b60be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1c626f8d491a96c517b5a165b60be5">&#9670;&nbsp;</a></span>VerifyBufsEqual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CRYPTOPP_DLL bool CRYPTOPP_API VerifyBufsEqual </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>buf1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>buf2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a near constant-time comparison of two equally sized buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf1</td><td>the first buffer </td></tr>
    <tr><td class="paramname">buf2</td><td>the second buffer </td></tr>
    <tr><td class="paramname">count</td><td>the size of the buffers, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The function effectively performs an XOR of the elements in two equally sized buffers and retruns a result based on the XOR operation. The function is near constant-time because CPU micro-code timings could affect the "constant-ness". Calling code is responsible for mitigating timing attacks if the buffers are <em>not</em> equally sized. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="misc_8h.html#a621695f6346d6a745e340513d917b31a" title="Reduces a value to a power of 2. ">ModPowerOf2</a> </dd></dl>

</div>
</div>
<a id="a7d2088e041288c140d06e1fba844e6e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2088e041288c140d06e1fba844e6e9">&#9670;&nbsp;</a></span>xorbuf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CRYPTOPP_DLL void CRYPTOPP_API xorbuf </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an XOR of a buffer with a mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer to XOR with the mask </td></tr>
    <tr><td class="paramname">mask</td><td>the mask to XOR with the buffer </td></tr>
    <tr><td class="paramname">count</td><td>the size of the buffers, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The function effectively visits each element in the buffers and performs <code>buf[i] ^= mask[i]</code>. buf and mask must be of equal size. </p>

</div>
</div>
<a id="a4db8a951de8dbc133bc845e21d2c59ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db8a951de8dbc133bc845e21d2c59ae">&#9670;&nbsp;</a></span>xorbuf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CRYPTOPP_DLL void CRYPTOPP_API xorbuf </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an XOR of an input buffer with a mask and stores the result in an output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>the destination buffer </td></tr>
    <tr><td class="paramname">input</td><td>the source buffer to XOR with the mask </td></tr>
    <tr><td class="paramname">mask</td><td>the mask buffer to XOR with the input buffer </td></tr>
    <tr><td class="paramname">count</td><td>the size of the buffers, in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The function effectively visits each element in the buffers and performs <code>output[i] = input[i] ^ mask[i]</code>. output, input and mask must be of equal size. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>

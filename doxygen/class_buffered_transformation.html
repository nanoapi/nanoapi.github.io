<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RaiBlocks: BufferedTransformation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RaiBlocks
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="class_buffered_transformation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BufferedTransformation Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface for buffered transformations.  
 <a href="class_buffered_transformation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cryptlib_8h_source.html">cryptlib.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BufferedTransformation:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_buffered_transformation.png" usemap="#BufferedTransformation_map" alt=""/>
  <map id="BufferedTransformation_map" name="BufferedTransformation_map">
<area href="class_algorithm.html" title="Interface for all crypto algorithms. " alt="Algorithm" shape="rect" coords="540,56,890,80"/>
<area href="class_waitable.html" title="Interface for objects that can be waited on. " alt="Waitable" shape="rect" coords="900,56,1250,80"/>
<area href="class_clonable.html" title="Interface for cloning objects. " alt="Clonable" shape="rect" coords="540,0,890,24"/>
<area href="class_auto_signaling.html" alt="AutoSignaling&lt; BufferedTransformation &gt;" shape="rect" coords="0,168,350,192"/>
<area href="class_bufferless.html" alt="Bufferless&lt; BufferedTransformation &gt;" shape="rect" coords="360,168,710,192"/>
<area href="class_filter.html" title="Implementation of BufferedTransformation&#39;s attachment interface. " alt="Filter" shape="rect" coords="720,168,1070,192"/>
<area href="class_input_rejecting.html" alt="InputRejecting&lt; BufferedTransformation &gt;" shape="rect" coords="1440,168,1790,192"/>
<area href="class_sink.html" title="Implementation of BufferedTransformation&#39;s attachment interface. " alt="Sink" shape="rect" coords="2160,168,2510,192"/>
<area href="class_message_queue.html" title="Message Queue. " alt="MessageQueue" shape="rect" coords="0,224,350,248"/>
<area href="class_byte_queue.html" title="Data structure used to store byte strings. " alt="ByteQueue" shape="rect" coords="360,224,710,248"/>
<area href="class_auto_signaling.html" alt="AutoSignaling&lt; Filter &gt;" shape="rect" coords="1080,224,1430,248"/>
<area href="class_bufferless.html" alt="Bufferless&lt; Filter &gt;" shape="rect" coords="1080,280,1430,304"/>
<area href="class_custom_flush_propagation.html" alt="CustomFlushPropagation&lt; Filter &gt;" shape="rect" coords="1080,336,1430,360"/>
<area href="class_encoded_object_filter.html" title="ASN.1 encoded object filter. " alt="EncodedObjectFilter" shape="rect" coords="1080,392,1430,416"/>
<area href="class_filter_with_buffered_input.html" title="Divides an input stream into discrete blocks. " alt="FilterWithBufferedInput" shape="rect" coords="1080,448,1430,472"/>
<area href="class_filter_with_input_queue.html" title="A filter that buffers input using a ByteQueue. " alt="FilterWithInputQueue" shape="rect" coords="1080,504,1430,528"/>
<area href="class_input_rejecting.html" alt="InputRejecting&lt; Filter &gt;" shape="rect" coords="1080,560,1430,584"/>
<area href="class_low_first_bit_writer.html" title="Encoding table writer. " alt="LowFirstBitWriter" shape="rect" coords="1080,616,1430,640"/>
<area href="class_unflushable.html" alt="Unflushable&lt; Filter &gt;" shape="rect" coords="1080,672,1430,696"/>
<area href="class_auto_signaling.html" alt="AutoSignaling&lt; InputRejecting&lt; BufferedTransformation &gt; &gt;" shape="rect" coords="1800,224,2150,248"/>
<area href="class_byte_queue_1_1_walker.html" title="A ByteQueue iterator. " alt="ByteQueue::Walker" shape="rect" coords="1800,280,2150,304"/>
<area href="class_bufferless.html" alt="Bufferless&lt; Sink &gt;" shape="rect" coords="2520,224,2870,248"/>
<area href="class_custom_flush_propagation.html" alt="CustomFlushPropagation&lt; Sink &gt;" shape="rect" coords="2520,280,2870,304"/>
<area href="class_file_sink.html" title="Implementation of Store interface. " alt="FileSink" shape="rect" coords="2520,336,2870,360"/>
<area href="class_unflushable.html" alt="Unflushable&lt; Sink &gt;" shape="rect" coords="2520,392,2870,416"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_buffered_transformation_1_1_blocking_input_only.html">BlockingInputOnly</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_exception.html" title="Base class for all exceptions thrown by the library. ">Exception</a> thrown by objects that have <em>not</em> implemented nonblocking input processing.  <a href="struct_buffered_transformation_1_1_blocking_input_only.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_buffered_transformation_1_1_invalid_channel_name.html">InvalidChannelName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_exception.html" title="Base class for all exceptions thrown by the library. ">Exception</a> thrown when a filter does not recognize a named channel.  <a href="struct_buffered_transformation_1_1_invalid_channel_name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_buffered_transformation_1_1_no_channel_support.html">NoChannelSupport</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_exception.html" title="Base class for all exceptions thrown by the library. ">Exception</a> thrown when a filter does not support named channels.  <a href="struct_buffered_transformation_1_1_no_channel_support.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a61bf430b7aa268991e3da82b74db1634"><td class="memItemLeft" align="right" valign="top"><a id="a61bf430b7aa268991e3da82b74db1634"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a61bf430b7aa268991e3da82b74db1634">BufferedTransformation</a> ()</td></tr>
<tr class="memdesc:a61bf430b7aa268991e3da82b74db1634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>. <br /></td></tr>
<tr class="separator:a61bf430b7aa268991e3da82b74db1634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25686ebe4c3ba26e7eeaae1dcd4d4215"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a25686ebe4c3ba26e7eeaae1dcd4d4215">Ref</a> ()</td></tr>
<tr class="memdesc:a25686ebe4c3ba26e7eeaae1dcd4d4215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a reference to this object.  <a href="#a25686ebe4c3ba26e7eeaae1dcd4d4215">More...</a><br /></td></tr>
<tr class="separator:a25686ebe4c3ba26e7eeaae1dcd4d4215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_algorithm"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_algorithm')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_algorithm.html">Algorithm</a></td></tr>
<tr class="memitem:a1c77f5117ca2cd881baf26a364cfc606 inherit pub_methods_class_algorithm"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm.html#a1c77f5117ca2cd881baf26a364cfc606">Algorithm</a> (bool checkSelfTestStatus=true)</td></tr>
<tr class="memdesc:a1c77f5117ca2cd881baf26a364cfc606 inherit pub_methods_class_algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for all crypto algorithms.  <a href="class_algorithm.html#a1c77f5117ca2cd881baf26a364cfc606">More...</a><br /></td></tr>
<tr class="separator:a1c77f5117ca2cd881baf26a364cfc606 inherit pub_methods_class_algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f31510a192d1121856efe8ad0a9b844 inherit pub_methods_class_algorithm"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm.html#a4f31510a192d1121856efe8ad0a9b844">AlgorithmName</a> () const</td></tr>
<tr class="memdesc:a4f31510a192d1121856efe8ad0a9b844 inherit pub_methods_class_algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the name of this algorithm.  <a href="class_algorithm.html#a4f31510a192d1121856efe8ad0a9b844">More...</a><br /></td></tr>
<tr class="separator:a4f31510a192d1121856efe8ad0a9b844 inherit pub_methods_class_algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_clonable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_clonable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_clonable.html">Clonable</a></td></tr>
<tr class="memitem:ad0016ba2d505c23aa85aad49e6c19bb7 inherit pub_methods_class_clonable"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_clonable.html">Clonable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_clonable.html#ad0016ba2d505c23aa85aad49e6c19bb7">Clone</a> () const</td></tr>
<tr class="memdesc:ad0016ba2d505c23aa85aad49e6c19bb7 inherit pub_methods_class_clonable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies this object.  <a href="class_clonable.html#ad0016ba2d505c23aa85aad49e6c19bb7">More...</a><br /></td></tr>
<tr class="separator:ad0016ba2d505c23aa85aad49e6c19bb7 inherit pub_methods_class_clonable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_waitable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_waitable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_waitable.html">Waitable</a></td></tr>
<tr class="memitem:aded81bbe562f61932306a64e6122a6ca inherit pub_methods_class_waitable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_waitable.html#aded81bbe562f61932306a64e6122a6ca">Wait</a> (unsigned long milliseconds, <a class="el" href="class_call_stack.html">CallStack</a> const &amp;callStack)</td></tr>
<tr class="memdesc:aded81bbe562f61932306a64e6122a6ca inherit pub_methods_class_waitable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on this object.  <a href="class_waitable.html#aded81bbe562f61932306a64e6122a6ca">More...</a><br /></td></tr>
<tr class="separator:aded81bbe562f61932306a64e6122a6ca inherit pub_methods_class_waitable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a0dc1428070dce0ce5651d775593ccce0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a0dc1428070dce0ce5651d775593ccce0">DecrementPropagation</a> (int propagation)</td></tr>
<tr class="memdesc:a0dc1428070dce0ce5651d775593ccce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the propagation count while clamping at 0.  <a href="#a0dc1428070dce0ce5651d775593ccce0">More...</a><br /></td></tr>
<tr class="separator:a0dc1428070dce0ce5651d775593ccce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
INPUT</h2></td></tr>
<tr class="memitem:ae70658b0d271f8e114ac6c3cc9774ede"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ae70658b0d271f8e114ac6c3cc9774ede">Put</a> (byte inByte, bool blocking=true)</td></tr>
<tr class="memdesc:ae70658b0d271f8e114ac6c3cc9774ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a byte for processing.  <a href="#ae70658b0d271f8e114ac6c3cc9774ede">More...</a><br /></td></tr>
<tr class="separator:ae70658b0d271f8e114ac6c3cc9774ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e935e60d3877975a7c82c6353d65c9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a44e935e60d3877975a7c82c6353d65c9">Put</a> (const byte *inString, size_t length, bool blocking=true)</td></tr>
<tr class="memdesc:a44e935e60d3877975a7c82c6353d65c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a byte buffer for processing.  <a href="#a44e935e60d3877975a7c82c6353d65c9">More...</a><br /></td></tr>
<tr class="separator:a44e935e60d3877975a7c82c6353d65c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c60616792d7bce5cd41eaffbd1c3cc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a92c60616792d7bce5cd41eaffbd1c3cc">PutWord16</a> (word16 value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>, bool blocking=true)</td></tr>
<tr class="memdesc:a92c60616792d7bce5cd41eaffbd1c3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a 16-bit word for processing.  <a href="#a92c60616792d7bce5cd41eaffbd1c3cc">More...</a><br /></td></tr>
<tr class="separator:a92c60616792d7bce5cd41eaffbd1c3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcc574867d51528afe3c96721ded075"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#affcc574867d51528afe3c96721ded075">PutWord32</a> (word32 value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>, bool blocking=true)</td></tr>
<tr class="memdesc:affcc574867d51528afe3c96721ded075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a 32-bit word for processing.  <a href="#affcc574867d51528afe3c96721ded075">More...</a><br /></td></tr>
<tr class="separator:affcc574867d51528afe3c96721ded075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af390325c959c3d6a2c03a447d6cd469d"><td class="memItemLeft" align="right" valign="top">virtual byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#af390325c959c3d6a2c03a447d6cd469d">CreatePutSpace</a> (size_t &amp;size)</td></tr>
<tr class="memdesc:af390325c959c3d6a2c03a447d6cd469d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request space which can be written into by the caller.  <a href="#af390325c959c3d6a2c03a447d6cd469d">More...</a><br /></td></tr>
<tr class="separator:af390325c959c3d6a2c03a447d6cd469d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5e36148728c1db63d9d3a6f5b49d7f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aff5e36148728c1db63d9d3a6f5b49d7f">CanModifyInput</a> () const</td></tr>
<tr class="memdesc:aff5e36148728c1db63d9d3a6f5b49d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether input can be modified by the callee.  <a href="#aff5e36148728c1db63d9d3a6f5b49d7f">More...</a><br /></td></tr>
<tr class="separator:aff5e36148728c1db63d9d3a6f5b49d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15df84a7b67c25dfe2ce0ef5a74123c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ae15df84a7b67c25dfe2ce0ef5a74123c">PutModifiable</a> (byte *inString, size_t length, bool blocking=true)</td></tr>
<tr class="memdesc:ae15df84a7b67c25dfe2ce0ef5a74123c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input multiple bytes that may be modified by callee.  <a href="#ae15df84a7b67c25dfe2ce0ef5a74123c">More...</a><br /></td></tr>
<tr class="separator:ae15df84a7b67c25dfe2ce0ef5a74123c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ae0ef2e4ff338b43849e541e9b940f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a20ae0ef2e4ff338b43849e541e9b940f">MessageEnd</a> (int propagation=-1, bool blocking=true)</td></tr>
<tr class="memdesc:a20ae0ef2e4ff338b43849e541e9b940f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals the end of messages to the object.  <a href="#a20ae0ef2e4ff338b43849e541e9b940f">More...</a><br /></td></tr>
<tr class="separator:a20ae0ef2e4ff338b43849e541e9b940f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10b7e626f5af900a4d12f6e5d125891"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aa10b7e626f5af900a4d12f6e5d125891">PutMessageEnd</a> (const byte *inString, size_t length, int propagation=-1, bool blocking=true)</td></tr>
<tr class="memdesc:aa10b7e626f5af900a4d12f6e5d125891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input multiple bytes for processing and signal the end of a message.  <a href="#aa10b7e626f5af900a4d12f6e5d125891">More...</a><br /></td></tr>
<tr class="separator:aa10b7e626f5af900a4d12f6e5d125891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad396dcb42260f23125a35ec0e5d17d55"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ad396dcb42260f23125a35ec0e5d17d55">Put2</a> (const byte *inString, size_t length, int messageEnd, bool blocking)=0</td></tr>
<tr class="memdesc:ad396dcb42260f23125a35ec0e5d17d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input multiple bytes for processing.  <a href="#ad396dcb42260f23125a35ec0e5d17d55">More...</a><br /></td></tr>
<tr class="separator:ad396dcb42260f23125a35ec0e5d17d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770bf11f26d4dec66423a7dc2d36843d"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a770bf11f26d4dec66423a7dc2d36843d">PutModifiable2</a> (byte *inString, size_t length, int messageEnd, bool blocking)</td></tr>
<tr class="memdesc:a770bf11f26d4dec66423a7dc2d36843d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input multiple bytes that may be modified by callee.  <a href="#a770bf11f26d4dec66423a7dc2d36843d">More...</a><br /></td></tr>
<tr class="separator:a770bf11f26d4dec66423a7dc2d36843d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
WAITING</h2></td></tr>
<tr class="memitem:a051a0b5e3e4cc81aca43a9c6cb02e0f9"><td class="memItemLeft" align="right" valign="top"><a id="a051a0b5e3e4cc81aca43a9c6cb02e0f9"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a051a0b5e3e4cc81aca43a9c6cb02e0f9">GetMaxWaitObjectCount</a> () const</td></tr>
<tr class="memdesc:a051a0b5e3e4cc81aca43a9c6cb02e0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the maximum number of waitable objects. <br /></td></tr>
<tr class="separator:a051a0b5e3e4cc81aca43a9c6cb02e0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127ccd1793fdda6548cd1295f848d0f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a127ccd1793fdda6548cd1295f848d0f7">GetWaitObjects</a> (<a class="el" href="class_wait_object_container.html">WaitObjectContainer</a> &amp;container, <a class="el" href="class_call_stack.html">CallStack</a> const &amp;callStack)</td></tr>
<tr class="memdesc:a127ccd1793fdda6548cd1295f848d0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves waitable objects.  <a href="#a127ccd1793fdda6548cd1295f848d0f7">More...</a><br /></td></tr>
<tr class="separator:a127ccd1793fdda6548cd1295f848d0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SIGNALS</h2></td></tr>
<tr class="memitem:a7bb05ac3b6302e2ab994586d526fa804"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a7bb05ac3b6302e2ab994586d526fa804">IsolatedInitialize</a> (const <a class="el" href="class_name_value_pairs.html">NameValuePairs</a> &amp;parameters)</td></tr>
<tr class="memdesc:a7bb05ac3b6302e2ab994586d526fa804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize or reinitialize this object, without signal propagation.  <a href="#a7bb05ac3b6302e2ab994586d526fa804">More...</a><br /></td></tr>
<tr class="separator:a7bb05ac3b6302e2ab994586d526fa804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68044dc8d57bc02edee1ce02b459a63d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a68044dc8d57bc02edee1ce02b459a63d">IsolatedFlush</a> (bool hardFlush, bool blocking)=0</td></tr>
<tr class="memdesc:a68044dc8d57bc02edee1ce02b459a63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes data buffered by this object, without signal propagation.  <a href="#a68044dc8d57bc02edee1ce02b459a63d">More...</a><br /></td></tr>
<tr class="separator:a68044dc8d57bc02edee1ce02b459a63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf09f0cd6dbd022539a9ac5c316d4984"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aaf09f0cd6dbd022539a9ac5c316d4984">IsolatedMessageSeriesEnd</a> (bool blocking)</td></tr>
<tr class="memdesc:aaf09f0cd6dbd022539a9ac5c316d4984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the end of a series of messages, without signal propagation.  <a href="#aaf09f0cd6dbd022539a9ac5c316d4984">More...</a><br /></td></tr>
<tr class="separator:aaf09f0cd6dbd022539a9ac5c316d4984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd5456c06e0e47d901e8055b50df929"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a0dd5456c06e0e47d901e8055b50df929">Initialize</a> (const <a class="el" href="class_name_value_pairs.html">NameValuePairs</a> &amp;parameters=<a class="el" href="cryptlib_8h.html#aa486a199e3e80fed67fb9a1992ca91e0">g_nullNameValuePairs</a>, int propagation=-1)</td></tr>
<tr class="memdesc:a0dd5456c06e0e47d901e8055b50df929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize or reinitialize this object, with signal propagation.  <a href="#a0dd5456c06e0e47d901e8055b50df929">More...</a><br /></td></tr>
<tr class="separator:a0dd5456c06e0e47d901e8055b50df929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a62b1b6c8f310363f32b05b20c306eb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a8a62b1b6c8f310363f32b05b20c306eb">Flush</a> (bool hardFlush, int propagation=-1, bool blocking=true)</td></tr>
<tr class="memdesc:a8a62b1b6c8f310363f32b05b20c306eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush buffered input and/or output, with signal propagation.  <a href="#a8a62b1b6c8f310363f32b05b20c306eb">More...</a><br /></td></tr>
<tr class="separator:a8a62b1b6c8f310363f32b05b20c306eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4c5ae024419e31bfa0c24eb35b24c2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aae4c5ae024419e31bfa0c24eb35b24c2">MessageSeriesEnd</a> (int propagation=-1, bool blocking=true)</td></tr>
<tr class="memdesc:aae4c5ae024419e31bfa0c24eb35b24c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the end of a series of messages, with signal propagation.  <a href="#aae4c5ae024419e31bfa0c24eb35b24c2">More...</a><br /></td></tr>
<tr class="separator:aae4c5ae024419e31bfa0c24eb35b24c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77dc2fddb3ff142effb00eff3217581"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ae77dc2fddb3ff142effb00eff3217581">SetAutoSignalPropagation</a> (int propagation)</td></tr>
<tr class="memdesc:ae77dc2fddb3ff142effb00eff3217581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set propagation of automatically generated and transferred signals.  <a href="#ae77dc2fddb3ff142effb00eff3217581">More...</a><br /></td></tr>
<tr class="separator:ae77dc2fddb3ff142effb00eff3217581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a32fc46e74c3c509934a11b8f5fec7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a76a32fc46e74c3c509934a11b8f5fec7">GetAutoSignalPropagation</a> () const</td></tr>
<tr class="memdesc:a76a32fc46e74c3c509934a11b8f5fec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve automatic signal propagation value.  <a href="#a76a32fc46e74c3c509934a11b8f5fec7">More...</a><br /></td></tr>
<tr class="separator:a76a32fc46e74c3c509934a11b8f5fec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
RETRIEVAL OF ONE MESSAGE</h2></td></tr>
<tr class="memitem:a30b2076bce5fb29e992b6457485c67c2"><td class="memItemLeft" align="right" valign="top">virtual lword&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a30b2076bce5fb29e992b6457485c67c2">MaxRetrievable</a> () const</td></tr>
<tr class="memdesc:a30b2076bce5fb29e992b6457485c67c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the number of bytes ready for retrieval.  <a href="#a30b2076bce5fb29e992b6457485c67c2">More...</a><br /></td></tr>
<tr class="separator:a30b2076bce5fb29e992b6457485c67c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1e2ca57fc06a1f3694d8fe7f8508ff"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a8c1e2ca57fc06a1f3694d8fe7f8508ff">AnyRetrievable</a> () const</td></tr>
<tr class="memdesc:a8c1e2ca57fc06a1f3694d8fe7f8508ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether bytes are ready for retrieval.  <a href="#a8c1e2ca57fc06a1f3694d8fe7f8508ff">More...</a><br /></td></tr>
<tr class="separator:a8c1e2ca57fc06a1f3694d8fe7f8508ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1ad913c8fe697d269f408a7d5928fc"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a9e1ad913c8fe697d269f408a7d5928fc">Get</a> (byte &amp;outByte)</td></tr>
<tr class="memdesc:a9e1ad913c8fe697d269f408a7d5928fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a 8-bit byte.  <a href="#a9e1ad913c8fe697d269f408a7d5928fc">More...</a><br /></td></tr>
<tr class="separator:a9e1ad913c8fe697d269f408a7d5928fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6f18a871720453e1791c64f0461a9f"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a0a6f18a871720453e1791c64f0461a9f">Get</a> (byte *outString, size_t getMax)</td></tr>
<tr class="memdesc:a0a6f18a871720453e1791c64f0461a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a block of bytes.  <a href="#a0a6f18a871720453e1791c64f0461a9f">More...</a><br /></td></tr>
<tr class="separator:a0a6f18a871720453e1791c64f0461a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d30db7e9ac411f51e33b56bb052b5b"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ae0d30db7e9ac411f51e33b56bb052b5b">Peek</a> (byte &amp;outByte) const</td></tr>
<tr class="memdesc:ae0d30db7e9ac411f51e33b56bb052b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek a 8-bit byte.  <a href="#ae0d30db7e9ac411f51e33b56bb052b5b">More...</a><br /></td></tr>
<tr class="separator:ae0d30db7e9ac411f51e33b56bb052b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796d9889c070ea85d9df262806579314"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a796d9889c070ea85d9df262806579314">Peek</a> (byte *outString, size_t peekMax) const</td></tr>
<tr class="memdesc:a796d9889c070ea85d9df262806579314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek a block of bytes.  <a href="#a796d9889c070ea85d9df262806579314">More...</a><br /></td></tr>
<tr class="separator:a796d9889c070ea85d9df262806579314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac50bcb2d279c3c6aef6858dab3eeb7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a1ac50bcb2d279c3c6aef6858dab3eeb7">GetWord16</a> (word16 &amp;value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>)</td></tr>
<tr class="memdesc:a1ac50bcb2d279c3c6aef6858dab3eeb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a 16-bit word.  <a href="#a1ac50bcb2d279c3c6aef6858dab3eeb7">More...</a><br /></td></tr>
<tr class="separator:a1ac50bcb2d279c3c6aef6858dab3eeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c064d931db3a8631c1138827d67e2f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a69c064d931db3a8631c1138827d67e2f">GetWord32</a> (word32 &amp;value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>)</td></tr>
<tr class="memdesc:a69c064d931db3a8631c1138827d67e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a 32-bit word.  <a href="#a69c064d931db3a8631c1138827d67e2f">More...</a><br /></td></tr>
<tr class="separator:a69c064d931db3a8631c1138827d67e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f6cc9f7a38884cde234f3367df62b6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a57f6cc9f7a38884cde234f3367df62b6">PeekWord16</a> (word16 &amp;value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>) const</td></tr>
<tr class="memdesc:a57f6cc9f7a38884cde234f3367df62b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek a 16-bit word.  <a href="#a57f6cc9f7a38884cde234f3367df62b6">More...</a><br /></td></tr>
<tr class="separator:a57f6cc9f7a38884cde234f3367df62b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bfe64be6bc1b65d84e3408e510b25a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a62bfe64be6bc1b65d84e3408e510b25a">PeekWord32</a> (word32 &amp;value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>) const</td></tr>
<tr class="memdesc:a62bfe64be6bc1b65d84e3408e510b25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek a 32-bit word.  <a href="#a62bfe64be6bc1b65d84e3408e510b25a">More...</a><br /></td></tr>
<tr class="separator:a62bfe64be6bc1b65d84e3408e510b25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31ac5d2da7897fb097086496b85e6f5"><td class="memItemLeft" align="right" valign="top">lword&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ac31ac5d2da7897fb097086496b85e6f5">TransferTo</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, lword transferMax=LWORD_MAX, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a>)</td></tr>
<tr class="memdesc:ac31ac5d2da7897fb097086496b85e6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">move transferMax bytes of the buffered output to target as input  <a href="#ac31ac5d2da7897fb097086496b85e6f5">More...</a><br /></td></tr>
<tr class="separator:ac31ac5d2da7897fb097086496b85e6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c25529ded99db20ad35ccef3f7234e6"><td class="memItemLeft" align="right" valign="top">virtual lword&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a0c25529ded99db20ad35ccef3f7234e6">Skip</a> (lword skipMax=LWORD_MAX)</td></tr>
<tr class="memdesc:a0c25529ded99db20ad35ccef3f7234e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard skipMax bytes from the output buffer.  <a href="#a0c25529ded99db20ad35ccef3f7234e6">More...</a><br /></td></tr>
<tr class="separator:a0c25529ded99db20ad35ccef3f7234e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7693f056b01bc4feadd8a794fba2d30a"><td class="memItemLeft" align="right" valign="top">lword&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a7693f056b01bc4feadd8a794fba2d30a">CopyTo</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, lword copyMax=LWORD_MAX, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a>) const</td></tr>
<tr class="memdesc:a7693f056b01bc4feadd8a794fba2d30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy copyMax bytes of the buffered output to target as input  <a href="#a7693f056b01bc4feadd8a794fba2d30a">More...</a><br /></td></tr>
<tr class="separator:a7693f056b01bc4feadd8a794fba2d30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac245e7a90e75e51482ce4421969616"><td class="memItemLeft" align="right" valign="top">lword&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a7ac245e7a90e75e51482ce4421969616">CopyRangeTo</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, lword position, lword copyMax=LWORD_MAX, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a>) const</td></tr>
<tr class="memdesc:a7ac245e7a90e75e51482ce4421969616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy bytes from this object using an index to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>.  <a href="#a7ac245e7a90e75e51482ce4421969616">More...</a><br /></td></tr>
<tr class="separator:a7ac245e7a90e75e51482ce4421969616"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
RETRIEVAL OF MULTIPLE MESSAGES</h2></td></tr>
<tr class="memitem:ab4e77f500d62436a8bd1597e6b6443a1"><td class="memItemLeft" align="right" valign="top">virtual lword&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ab4e77f500d62436a8bd1597e6b6443a1">TotalBytesRetrievable</a> () const</td></tr>
<tr class="memdesc:ab4e77f500d62436a8bd1597e6b6443a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the number of bytes ready for retrieval.  <a href="#ab4e77f500d62436a8bd1597e6b6443a1">More...</a><br /></td></tr>
<tr class="separator:ab4e77f500d62436a8bd1597e6b6443a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bcbb4306a9c04cda838f96e85a2116"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a56bcbb4306a9c04cda838f96e85a2116">NumberOfMessages</a> () const</td></tr>
<tr class="memdesc:a56bcbb4306a9c04cda838f96e85a2116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the number of meesages processed by this object.  <a href="#a56bcbb4306a9c04cda838f96e85a2116">More...</a><br /></td></tr>
<tr class="separator:a56bcbb4306a9c04cda838f96e85a2116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d7fdaa525a59cf72cdc431570f3df8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aa0d7fdaa525a59cf72cdc431570f3df8">AnyMessages</a> () const</td></tr>
<tr class="memdesc:aa0d7fdaa525a59cf72cdc431570f3df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if any messages are available for retrieval.  <a href="#aa0d7fdaa525a59cf72cdc431570f3df8">More...</a><br /></td></tr>
<tr class="separator:aa0d7fdaa525a59cf72cdc431570f3df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc8562950fd563f7c62d1f1e5ec6b1e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a8dc8562950fd563f7c62d1f1e5ec6b1e">GetNextMessage</a> ()</td></tr>
<tr class="memdesc:a8dc8562950fd563f7c62d1f1e5ec6b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start retrieving the next message.  <a href="#a8dc8562950fd563f7c62d1f1e5ec6b1e">More...</a><br /></td></tr>
<tr class="separator:a8dc8562950fd563f7c62d1f1e5ec6b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace560f14489f478bb4cd17c41905774e"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ace560f14489f478bb4cd17c41905774e">SkipMessages</a> (unsigned int count=UINT_MAX)</td></tr>
<tr class="memdesc:ace560f14489f478bb4cd17c41905774e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip a number of meessages.  <a href="#ace560f14489f478bb4cd17c41905774e">More...</a><br /></td></tr>
<tr class="separator:ace560f14489f478bb4cd17c41905774e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0446d21781676a6f9c64d0b7a727d314"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a0446d21781676a6f9c64d0b7a727d314">TransferMessagesTo</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, unsigned int count=UINT_MAX, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a>)</td></tr>
<tr class="memdesc:a0446d21781676a6f9c64d0b7a727d314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer messages from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>.  <a href="#a0446d21781676a6f9c64d0b7a727d314">More...</a><br /></td></tr>
<tr class="separator:a0446d21781676a6f9c64d0b7a727d314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4b2099b75141367e96ce60c6eb939f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a2d4b2099b75141367e96ce60c6eb939f">CopyMessagesTo</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, unsigned int count=UINT_MAX, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a>) const</td></tr>
<tr class="memdesc:a2d4b2099b75141367e96ce60c6eb939f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy messages from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>.  <a href="#a2d4b2099b75141367e96ce60c6eb939f">More...</a><br /></td></tr>
<tr class="separator:a2d4b2099b75141367e96ce60c6eb939f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae2c7846a506939b40c2c8b708af1d4"><td class="memItemLeft" align="right" valign="top"><a id="aaae2c7846a506939b40c2c8b708af1d4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aaae2c7846a506939b40c2c8b708af1d4">SkipAll</a> ()</td></tr>
<tr class="memdesc:aaae2c7846a506939b40c2c8b708af1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip all messages in the series. <br /></td></tr>
<tr class="separator:aaae2c7846a506939b40c2c8b708af1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c3629cdd9be90695c9701c1b8e24a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a84c3629cdd9be90695c9701c1b8e24a2">TransferAllTo</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a>)</td></tr>
<tr class="memdesc:a84c3629cdd9be90695c9701c1b8e24a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer all bytes from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>.  <a href="#a84c3629cdd9be90695c9701c1b8e24a2">More...</a><br /></td></tr>
<tr class="separator:a84c3629cdd9be90695c9701c1b8e24a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18893c1bd5eee9263022f72d4ac992ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a18893c1bd5eee9263022f72d4ac992ad">CopyAllTo</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a>) const</td></tr>
<tr class="memdesc:a18893c1bd5eee9263022f72d4ac992ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy messages from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>.  <a href="#a18893c1bd5eee9263022f72d4ac992ad">More...</a><br /></td></tr>
<tr class="separator:a18893c1bd5eee9263022f72d4ac992ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb36a158b63cfd54acbada1a3699598c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aeb36a158b63cfd54acbada1a3699598c">GetNextMessageSeries</a> ()</td></tr>
<tr class="memdesc:aeb36a158b63cfd54acbada1a3699598c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the next message in a series.  <a href="#aeb36a158b63cfd54acbada1a3699598c">More...</a><br /></td></tr>
<tr class="separator:aeb36a158b63cfd54acbada1a3699598c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced989ed6c34a7e91c725df5daffcf57"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aced989ed6c34a7e91c725df5daffcf57">NumberOfMessagesInThisSeries</a> () const</td></tr>
<tr class="memdesc:aced989ed6c34a7e91c725df5daffcf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the number of messages in a series.  <a href="#aced989ed6c34a7e91c725df5daffcf57">More...</a><br /></td></tr>
<tr class="separator:aced989ed6c34a7e91c725df5daffcf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b83d07c4e05a86e054fbaa32e50468"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ad1b83d07c4e05a86e054fbaa32e50468">NumberOfMessageSeries</a> () const</td></tr>
<tr class="memdesc:ad1b83d07c4e05a86e054fbaa32e50468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the number of messages in a series.  <a href="#ad1b83d07c4e05a86e054fbaa32e50468">More...</a><br /></td></tr>
<tr class="separator:ad1b83d07c4e05a86e054fbaa32e50468"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
NON-BLOCKING TRANSFER OF OUTPUT</h2></td></tr>
<tr class="memitem:a27ac15af3ef43c5ad1e9db5812025fcd"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a27ac15af3ef43c5ad1e9db5812025fcd">TransferTo2</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, lword &amp;byteCount, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a>, bool blocking=true)=0</td></tr>
<tr class="memdesc:a27ac15af3ef43c5ad1e9db5812025fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer bytes from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>.  <a href="#a27ac15af3ef43c5ad1e9db5812025fcd">More...</a><br /></td></tr>
<tr class="separator:a27ac15af3ef43c5ad1e9db5812025fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f90ef36f633c97c1ae519b800527d8e"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a7f90ef36f633c97c1ae519b800527d8e">CopyRangeTo2</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, lword &amp;begin, lword end=LWORD_MAX, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a>, bool blocking=true) const =0</td></tr>
<tr class="memdesc:a7f90ef36f633c97c1ae519b800527d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy bytes from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>.  <a href="#a7f90ef36f633c97c1ae519b800527d8e">More...</a><br /></td></tr>
<tr class="separator:a7f90ef36f633c97c1ae519b800527d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a70058989762156c376d7ffa5cb303e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a1a70058989762156c376d7ffa5cb303e">TransferMessagesTo2</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, unsigned int &amp;messageCount, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a>, bool blocking=true)</td></tr>
<tr class="memdesc:a1a70058989762156c376d7ffa5cb303e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer messages from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>.  <a href="#a1a70058989762156c376d7ffa5cb303e">More...</a><br /></td></tr>
<tr class="separator:a1a70058989762156c376d7ffa5cb303e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e47718aa65674256e1b069ec8e706b7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a3e47718aa65674256e1b069ec8e706b7">TransferAllTo2</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;target, const std::string &amp;channel=<a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a>, bool blocking=true)</td></tr>
<tr class="memdesc:a3e47718aa65674256e1b069ec8e706b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer all bytes from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>.  <a href="#a3e47718aa65674256e1b069ec8e706b7">More...</a><br /></td></tr>
<tr class="separator:a3e47718aa65674256e1b069ec8e706b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
CHANNELS</h2></td></tr>
<tr class="memitem:a97a60b54fafdb3df59e1457ef629fc5f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a97a60b54fafdb3df59e1457ef629fc5f">ChannelPut</a> (const std::string &amp;channel, byte inByte, bool blocking=true)</td></tr>
<tr class="memdesc:a97a60b54fafdb3df59e1457ef629fc5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a byte for processing on a channel.  <a href="#a97a60b54fafdb3df59e1457ef629fc5f">More...</a><br /></td></tr>
<tr class="separator:a97a60b54fafdb3df59e1457ef629fc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7fcb31b4cb09d38242354fcbc4b45c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a5b7fcb31b4cb09d38242354fcbc4b45c">ChannelPut</a> (const std::string &amp;channel, const byte *inString, size_t length, bool blocking=true)</td></tr>
<tr class="memdesc:a5b7fcb31b4cb09d38242354fcbc4b45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a byte buffer for processing on a channel.  <a href="#a5b7fcb31b4cb09d38242354fcbc4b45c">More...</a><br /></td></tr>
<tr class="separator:a5b7fcb31b4cb09d38242354fcbc4b45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc27692b14108ed057beb4db67fed2f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a3dc27692b14108ed057beb4db67fed2f">ChannelPutModifiable</a> (const std::string &amp;channel, byte *inString, size_t length, bool blocking=true)</td></tr>
<tr class="memdesc:a3dc27692b14108ed057beb4db67fed2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input multiple bytes that may be modified by callee on a channel.  <a href="#a3dc27692b14108ed057beb4db67fed2f">More...</a><br /></td></tr>
<tr class="separator:a3dc27692b14108ed057beb4db67fed2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bca66c16e0e52793059b41353964bd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aa1bca66c16e0e52793059b41353964bd">ChannelPutWord16</a> (const std::string &amp;channel, word16 value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>, bool blocking=true)</td></tr>
<tr class="memdesc:aa1bca66c16e0e52793059b41353964bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a 16-bit word for processing on a channel.  <a href="#aa1bca66c16e0e52793059b41353964bd">More...</a><br /></td></tr>
<tr class="separator:aa1bca66c16e0e52793059b41353964bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb06216012d6c40609db092952afcf3f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#acb06216012d6c40609db092952afcf3f">ChannelPutWord32</a> (const std::string &amp;channel, word32 value, <a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a> order=<a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a>, bool blocking=true)</td></tr>
<tr class="memdesc:acb06216012d6c40609db092952afcf3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a 32-bit word for processing on a channel.  <a href="#acb06216012d6c40609db092952afcf3f">More...</a><br /></td></tr>
<tr class="separator:acb06216012d6c40609db092952afcf3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b37b299c5835083e58b205f9cc25cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ae0b37b299c5835083e58b205f9cc25cc">ChannelMessageEnd</a> (const std::string &amp;channel, int propagation=-1, bool blocking=true)</td></tr>
<tr class="memdesc:ae0b37b299c5835083e58b205f9cc25cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal the end of a message.  <a href="#ae0b37b299c5835083e58b205f9cc25cc">More...</a><br /></td></tr>
<tr class="separator:ae0b37b299c5835083e58b205f9cc25cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e9efe4c59093c330d287140fcfbdd9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ad3e9efe4c59093c330d287140fcfbdd9">ChannelPutMessageEnd</a> (const std::string &amp;channel, const byte *inString, size_t length, int propagation=-1, bool blocking=true)</td></tr>
<tr class="memdesc:ad3e9efe4c59093c330d287140fcfbdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input multiple bytes for processing and signal the end of a message.  <a href="#ad3e9efe4c59093c330d287140fcfbdd9">More...</a><br /></td></tr>
<tr class="separator:ad3e9efe4c59093c330d287140fcfbdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877494d8de597af935cb770034f7f170"><td class="memItemLeft" align="right" valign="top">virtual byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a877494d8de597af935cb770034f7f170">ChannelCreatePutSpace</a> (const std::string &amp;channel, size_t &amp;size)</td></tr>
<tr class="memdesc:a877494d8de597af935cb770034f7f170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request space which can be written into by the caller.  <a href="#a877494d8de597af935cb770034f7f170">More...</a><br /></td></tr>
<tr class="separator:a877494d8de597af935cb770034f7f170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b026f47d8a0ea2e35a6cb8d9ec2c97"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ae6b026f47d8a0ea2e35a6cb8d9ec2c97">ChannelPut2</a> (const std::string &amp;channel, const byte *inString, size_t length, int messageEnd, bool blocking)</td></tr>
<tr class="memdesc:ae6b026f47d8a0ea2e35a6cb8d9ec2c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input multiple bytes for processing on a channel.  <a href="#ae6b026f47d8a0ea2e35a6cb8d9ec2c97">More...</a><br /></td></tr>
<tr class="separator:ae6b026f47d8a0ea2e35a6cb8d9ec2c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2a8b1b88a881edf8bebe089438fc66"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#add2a8b1b88a881edf8bebe089438fc66">ChannelPutModifiable2</a> (const std::string &amp;channel, byte *inString, size_t length, int messageEnd, bool blocking)</td></tr>
<tr class="memdesc:add2a8b1b88a881edf8bebe089438fc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input multiple bytes that may be modified by callee on a channel.  <a href="#add2a8b1b88a881edf8bebe089438fc66">More...</a><br /></td></tr>
<tr class="separator:add2a8b1b88a881edf8bebe089438fc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b504b2694ecb5d709a9858c5b93a0f7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a6b504b2694ecb5d709a9858c5b93a0f7">ChannelFlush</a> (const std::string &amp;channel, bool hardFlush, int propagation=-1, bool blocking=true)</td></tr>
<tr class="memdesc:a6b504b2694ecb5d709a9858c5b93a0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush buffered input and/or output on a channel.  <a href="#a6b504b2694ecb5d709a9858c5b93a0f7">More...</a><br /></td></tr>
<tr class="separator:a6b504b2694ecb5d709a9858c5b93a0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fc63d42d94958f71fc573b17469921"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ae0fc63d42d94958f71fc573b17469921">ChannelMessageSeriesEnd</a> (const std::string &amp;channel, int propagation=-1, bool blocking=true)</td></tr>
<tr class="memdesc:ae0fc63d42d94958f71fc573b17469921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the end of a series of messages on a channel.  <a href="#ae0fc63d42d94958f71fc573b17469921">More...</a><br /></td></tr>
<tr class="separator:ae0fc63d42d94958f71fc573b17469921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb151c318a472c5f1cf41617f3414a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aeeb151c318a472c5f1cf41617f3414a5">SetRetrievalChannel</a> (const std::string &amp;channel)</td></tr>
<tr class="memdesc:aeeb151c318a472c5f1cf41617f3414a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default retrieval channel.  <a href="#aeeb151c318a472c5f1cf41617f3414a5">More...</a><br /></td></tr>
<tr class="separator:aeeb151c318a472c5f1cf41617f3414a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
ATTACHMENT</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp357bd74edad7a5ca38986b70368e07b5"></a>Some <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a> objects (e.g. <a class="el" href="class_filter.html" title="Implementation of BufferedTransformation&#39;s attachment interface. ">Filter</a> objects) allow other <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a> objects to be attached. When this is done, the first object instead of buffering its output, sends that output to the attached object as input. The entire attachment chain is deleted when the anchor object is destructed. </p>
</td></tr>
<tr class="memitem:a20112606fc006c56f1561653cabd9542"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a20112606fc006c56f1561653cabd9542">Attachable</a> ()</td></tr>
<tr class="memdesc:a20112606fc006c56f1561653cabd9542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the object allows attachment.  <a href="#a20112606fc006c56f1561653cabd9542">More...</a><br /></td></tr>
<tr class="separator:a20112606fc006c56f1561653cabd9542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6bbc169e26ed77a6bb5d50f91abda0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0">AttachedTransformation</a> ()</td></tr>
<tr class="memdesc:aba6bbc169e26ed77a6bb5d50f91abda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object immediately attached to this object.  <a href="#aba6bbc169e26ed77a6bb5d50f91abda0">More...</a><br /></td></tr>
<tr class="separator:aba6bbc169e26ed77a6bb5d50f91abda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14186840b67e8ebc9c05d1eb581598d"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#ab14186840b67e8ebc9c05d1eb581598d">AttachedTransformation</a> () const</td></tr>
<tr class="memdesc:ab14186840b67e8ebc9c05d1eb581598d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object immediately attached to this object.  <a href="#ab14186840b67e8ebc9c05d1eb581598d">More...</a><br /></td></tr>
<tr class="separator:ab14186840b67e8ebc9c05d1eb581598d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d101fec1e0eafaacb9458804354c9c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a7d101fec1e0eafaacb9458804354c9c8">Detach</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> *newAttachment=NULLPTR)</td></tr>
<tr class="memdesc:a7d101fec1e0eafaacb9458804354c9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the current attachment chain and attach a new one.  <a href="#a7d101fec1e0eafaacb9458804354c9c8">More...</a><br /></td></tr>
<tr class="separator:a7d101fec1e0eafaacb9458804354c9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6cbec970dcb509b23a08fb28b3e055"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_transformation.html#a9f6cbec970dcb509b23a08fb28b3e055">Attach</a> (<a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> *newAttachment)</td></tr>
<tr class="memdesc:a9f6cbec970dcb509b23a08fb28b3e055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add newAttachment to the end of attachment chain.  <a href="#a9f6cbec970dcb509b23a08fb28b3e055">More...</a><br /></td></tr>
<tr class="separator:a9f6cbec970dcb509b23a08fb28b3e055"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface for buffered transformations. </p>
<p><a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a> is a generalization of <a class="el" href="class_block_transformation.html" title="Interface for the data processing part of block ciphers. ">BlockTransformation</a>, <a class="el" href="class_stream_transformation.html" title="Interface for the data processing portion of stream ciphers. ">StreamTransformation</a> and <a class="el" href="class_hash_transformation.html" title="Interface for hash functions and data processing part of MACs. ">HashTransformation</a>.</p>
<p>A buffered transformation is an object that takes a stream of bytes as input (this may be done in stages), does some computation on them, and then places the result into an internal buffer for later retrieval. Any partial result already in the output buffer is not modified by further input.</p>
<p>If a method takes a "blocking" parameter, and you pass false for it, then the method will return before all input has been processed if the input cannot be processed without waiting (for network buffers to become available, for example). In this case the method will return true or a non-zero integer value. When this happens you must continue to call the method with the same parameters until it returns false or zero, before calling any other method on it or attached /p <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>. The integer return value in this case is approximately the number of bytes left to be processed, and can be used to implement a progress bar.</p>
<p>For functions that take a "propagation" parameter, <code>propagation != 0</code> means pass on the signal to attached <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a> objects, with propagation decremented at each step until it reaches <code>0</code>. <code>-1</code> means unlimited propagation.</p>
<p><em>All</em> of the retrieval functions, like <a class="el" href="class_buffered_transformation.html#a9e1ad913c8fe697d269f408a7d5928fc" title="Retrieve a 8-bit byte. ">Get()</a> and <a class="el" href="class_buffered_transformation.html#a69c064d931db3a8631c1138827d67e2f" title="Retrieve a 32-bit word. ">GetWord32()</a>, return the actual number of bytes retrieved, which is the lesser of the request number and <a class="el" href="class_buffered_transformation.html#a30b2076bce5fb29e992b6457485c67c2" title="Provides the number of bytes ready for retrieval. ">MaxRetrievable()</a>.</p>
<p><em>Most</em> of the input functions, like <a class="el" href="class_buffered_transformation.html#ae70658b0d271f8e114ac6c3cc9774ede" title="Input a byte for processing. ">Put()</a> and <a class="el" href="class_buffered_transformation.html#affcc574867d51528afe3c96721ded075" title="Input a 32-bit word for processing. ">PutWord32()</a>, return the number of bytes remaining to be processed. A 0 value means all bytes were processed, and a non-0 value means bytes remain to be processed. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aa0d7fdaa525a59cf72cdc431570f3df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d7fdaa525a59cf72cdc431570f3df8">&#9670;&nbsp;</a></span>AnyMessages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BufferedTransformation::AnyMessages </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if any messages are available for retrieval. </p>
<dl class="section return"><dt>Returns</dt><dd>true if <code><a class="el" href="class_buffered_transformation.html#a56bcbb4306a9c04cda838f96e85a2116" title="Provides the number of meesages processed by this object. ">NumberOfMessages()</a> &gt; 0</code>, false otherwise</dd></dl>
<p>AnyMessages returns true if <code><a class="el" href="class_buffered_transformation.html#a56bcbb4306a9c04cda838f96e85a2116" title="Provides the number of meesages processed by this object. ">NumberOfMessages()</a> &gt; 0</code> </p>

</div>
</div>
<a id="a8c1e2ca57fc06a1f3694d8fe7f8508ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1e2ca57fc06a1f3694d8fe7f8508ff">&#9670;&nbsp;</a></span>AnyRetrievable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BufferedTransformation::AnyRetrievable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether bytes are ready for retrieval. </p>
<dl class="section return"><dt>Returns</dt><dd>true if bytes are available for retrieval, false otherwise </dd></dl>

<p>Reimplemented in <a class="el" href="class_random_number_store.html#a036cdd35be6f6dc847b8ea17f6d8a9e8">RandomNumberStore</a>, <a class="el" href="class_message_queue.html#a1f9ba84c015a1ca041ae7765c423e711">MessageQueue</a>, and <a class="el" href="class_byte_queue.html#ae0d701bf528a1131917b77c0bb3fb369">ByteQueue</a>.</p>

</div>
</div>
<a id="a9f6cbec970dcb509b23a08fb28b3e055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6cbec970dcb509b23a08fb28b3e055">&#9670;&nbsp;</a></span>Attach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BufferedTransformation::Attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> *&#160;</td>
          <td class="paramname"><em>newAttachment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add newAttachment to the end of attachment chain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newAttachment</td><td>the attachment to add to the end of the chain </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20112606fc006c56f1561653cabd9542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20112606fc006c56f1561653cabd9542">&#9670;&nbsp;</a></span>Attachable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool BufferedTransformation::Attachable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the object allows attachment. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the object allows an attachment, false otherwise</dd></dl>
<p>Sources and Filters will returns true, while Sinks and other objects will return false. </p>

<p>Reimplemented in <a class="el" href="class_filter.html#a6e7251247b5c2cc3b0c15e861cc88e16">Filter</a>.</p>

</div>
</div>
<a id="aba6bbc169e26ed77a6bb5d50f91abda0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6bbc169e26ed77a6bb5d50f91abda0">&#9670;&nbsp;</a></span>AttachedTransformation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_buffered_transformation.html">BufferedTransformation</a>* BufferedTransformation::AttachedTransformation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object immediately attached to this object. </p>
<dl class="section return"><dt>Returns</dt><dd>the attached transformation</dd></dl>
<p><a class="el" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="Returns the object immediately attached to this object. ">AttachedTransformation()</a> returns NULL if there is no attachment. The non-const version of <a class="el" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="Returns the object immediately attached to this object. ">AttachedTransformation()</a> always returns NULL. </p>

<p>Reimplemented in <a class="el" href="class_filter.html#ac8fc888888b2dad88bf64fc703044a93">Filter</a>.</p>

</div>
</div>
<a id="ab14186840b67e8ebc9c05d1eb581598d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14186840b67e8ebc9c05d1eb581598d">&#9670;&nbsp;</a></span>AttachedTransformation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_buffered_transformation.html">BufferedTransformation</a>* BufferedTransformation::AttachedTransformation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object immediately attached to this object. </p>
<dl class="section return"><dt>Returns</dt><dd>the attached transformation</dd></dl>
<p><a class="el" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="Returns the object immediately attached to this object. ">AttachedTransformation()</a> returns NULL if there is no attachment. The non-const version of <a class="el" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="Returns the object immediately attached to this object. ">AttachedTransformation()</a> always returns NULL. </p>

<p>Reimplemented in <a class="el" href="class_filter.html#a049148324c63bda47ac676f64e113b26">Filter</a>.</p>

</div>
</div>
<a id="aff5e36148728c1db63d9d3a6f5b49d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5e36148728c1db63d9d3a6f5b49d7f">&#9670;&nbsp;</a></span>CanModifyInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool BufferedTransformation::CanModifyInput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether input can be modified by the callee. </p>
<dl class="section return"><dt>Returns</dt><dd>true if input can be modified, false otherwise</dd></dl>
<p>The base class implementation returns false. </p>

<p>Reimplemented in <a class="el" href="class_redirector.html#a2ee0003a41e0fbebe12ff2b4d9f19559">Redirector</a>.</p>

</div>
</div>
<a id="a877494d8de597af935cb770034f7f170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877494d8de597af935cb770034f7f170">&#9670;&nbsp;</a></span>ChannelCreatePutSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte * BufferedTransformation::ChannelCreatePutSpace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request space which can be written into by the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to process the data </td></tr>
    <tr><td class="paramname">size</td><td>the requested size of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a memroy block with length size</dd></dl>
<p>The purpose of this method is to help avoid extra memory allocations.</p>
<p>size is an <em>IN</em> and <em>OUT</em> parameter and used as a hint. When the call is made, size is the requested size of the buffer. When the call returns, size is the size of the array returned to the caller.</p>
<p>The base class implementation sets size to 0 and returns NULL. </p><dl class="section note"><dt>Note</dt><dd>Some objects, like <a class="el" href="class_array_sink.html" title="Copy input to a memory buffer. ">ArraySink()</a>, cannot create a space because its fixed. In the case of an <a class="el" href="class_array_sink.html" title="Copy input to a memory buffer. ">ArraySink()</a>, the pointer to the array is returned and the size is remaining size. </dd></dl>

<p>Reimplemented in <a class="el" href="class_output_proxy.html#a51301674845151fb1e6b9f599d6ffbc9">OutputProxy</a>, <a class="el" href="class_redirector.html#a6e882384f0214dfc148abf38955ec0e5">Redirector</a>, <a class="el" href="class_authenticated_decryption_filter.html#af4e30b147daa507238e9bee3715a3a23">AuthenticatedDecryptionFilter</a>, <a class="el" href="class_authenticated_encryption_filter.html#a7e50639e227b5a0f6f184a69e6d48642">AuthenticatedEncryptionFilter</a>, and <a class="el" href="class_channel_switch.html#a2d9c7bc18d12303c77f7cd4ad355a6f8">ChannelSwitch</a>.</p>

</div>
</div>
<a id="a6b504b2694ecb5d709a9858c5b93a0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b504b2694ecb5d709a9858c5b93a0f7">&#9670;&nbsp;</a></span>ChannelFlush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BufferedTransformation::ChannelFlush </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hardFlush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propagation</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush buffered input and/or output on a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to flush the data </td></tr>
    <tr><td class="paramname">hardFlush</td><td>is used to indicate whether all data should be flushed </td></tr>
    <tr><td class="paramname">propagation</td><td>the number of attached transformations the <a class="el" href="class_buffered_transformation.html#a6b504b2694ecb5d709a9858c5b93a0f7" title="Flush buffered input and/or output on a channel. ">ChannelFlush()</a> signal should be passed </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true of the Flush was successful</dd></dl>
<p>propagation count includes this object. Setting propagation to <code>1</code> means this object only. Setting propagation to <code>-1</code> means unlimited propagation. </p>

<p>Reimplemented in <a class="el" href="class_output_proxy.html#a7aeaa853d3be4abac2b65fa45b5763db">OutputProxy</a>, <a class="el" href="class_redirector.html#a9dde3ac97812d4ba31245f46192cb627">Redirector</a>, and <a class="el" href="class_channel_switch.html#a35f25c2c035162f840088df46d905584">ChannelSwitch</a>.</p>

</div>
</div>
<a id="ae0b37b299c5835083e58b205f9cc25cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b37b299c5835083e58b205f9cc25cc">&#9670;&nbsp;</a></span>ChannelMessageEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BufferedTransformation::ChannelMessageEnd </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propagation</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal the end of a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to process the data. </td></tr>
    <tr><td class="paramname">propagation</td><td>the number of attached transformations the <a class="el" href="class_buffered_transformation.html#ae0b37b299c5835083e58b205f9cc25cc" title="Signal the end of a message. ">ChannelMessageEnd()</a> signal should be passed </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 indicates all bytes were processed during the call. Non-0 indicates the number of bytes that were <em>not</em> processed.</dd></dl>
<p>propagation count includes this object. Setting propagation to <code>1</code> means this object only. Setting propagation to <code>-1</code> means unlimited propagation. </p>

</div>
</div>
<a id="ae0fc63d42d94958f71fc573b17469921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0fc63d42d94958f71fc573b17469921">&#9670;&nbsp;</a></span>ChannelMessageSeriesEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BufferedTransformation::ChannelMessageSeriesEnd </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propagation</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the end of a series of messages on a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to signal the end of a series of messages </td></tr>
    <tr><td class="paramname">propagation</td><td>the number of attached transformations the <a class="el" href="class_buffered_transformation.html#ae0fc63d42d94958f71fc573b17469921" title="Marks the end of a series of messages on a channel. ">ChannelMessageSeriesEnd()</a> signal should be passed </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input</td></tr>
  </table>
  </dd>
</dl>
<p>Each object that receives the signal will perform its processing, decrement propagation, and then pass the signal on to attached transformations if the value is not 0.</p>
<p>propagation count includes this object. Setting propagation to <code>1</code> means this object only. Setting propagation to <code>-1</code> means unlimited propagation. </p><dl class="section note"><dt>Note</dt><dd>There should be a <a class="el" href="class_buffered_transformation.html#a20ae0ef2e4ff338b43849e541e9b940f" title="Signals the end of messages to the object. ">MessageEnd()</a> immediately before <a class="el" href="class_buffered_transformation.html#aae4c5ae024419e31bfa0c24eb35b24c2" title="Marks the end of a series of messages, with signal propagation. ">MessageSeriesEnd()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="class_output_proxy.html#aae129d7efb204cbe5c733032de298fcc">OutputProxy</a>, <a class="el" href="class_redirector.html#a827e4af441934015de54ceb14334503d">Redirector</a>, <a class="el" href="class_channel_switch.html#a1459e69e94c5cd4aef42191635c07c1c">ChannelSwitch</a>, and <a class="el" href="class_equality_comparison_filter.html#a97d5eb6fd119c9bdbee7d08b98450667">EqualityComparisonFilter</a>.</p>

</div>
</div>
<a id="a97a60b54fafdb3df59e1457ef629fc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a60b54fafdb3df59e1457ef629fc5f">&#9670;&nbsp;</a></span>ChannelPut() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::ChannelPut </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>inByte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input a byte for processing on a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to process the data. </td></tr>
    <tr><td class="paramname">inByte</td><td>the 8-bit byte (octet) to be processed. </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 indicates all bytes were processed during the call. Non-0 indicates the number of bytes that were <em>not</em> processed. </dd></dl>

</div>
</div>
<a id="a5b7fcb31b4cb09d38242354fcbc4b45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7fcb31b4cb09d38242354fcbc4b45c">&#9670;&nbsp;</a></span>ChannelPut() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::ChannelPut </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>inString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input a byte buffer for processing on a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to process the data </td></tr>
    <tr><td class="paramname">inString</td><td>the byte buffer to process </td></tr>
    <tr><td class="paramname">length</td><td>the size of the string, in bytes </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 indicates all bytes were processed during the call. Non-0 indicates the number of bytes that were <em>not</em> processed. </dd></dl>

</div>
</div>
<a id="ae6b026f47d8a0ea2e35a6cb8d9ec2c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b026f47d8a0ea2e35a6cb8d9ec2c97">&#9670;&nbsp;</a></span>ChannelPut2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::ChannelPut2 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>inString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>messageEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input multiple bytes for processing on a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to process the data. </td></tr>
    <tr><td class="paramname">inString</td><td>the byte buffer to process. </td></tr>
    <tr><td class="paramname">length</td><td>the size of the string, in bytes. </td></tr>
    <tr><td class="paramname">messageEnd</td><td>means how many filters to signal <a class="el" href="class_buffered_transformation.html#a20ae0ef2e4ff338b43849e541e9b940f" title="Signals the end of messages to the object. ">MessageEnd()</a> to, including this one. </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that remain in the block (i.e., bytes not processed) </dd></dl>

<p>Reimplemented in <a class="el" href="class_output_proxy.html#a13ff9fb43d2b5d08e83a130b630c907a">OutputProxy</a>, <a class="el" href="class_redirector.html#acd6d9e39c8d0f95d99b41129f1c97dae">Redirector</a>, <a class="el" href="class_authenticated_decryption_filter.html#af29b21590d82a985e63540276b0fde75">AuthenticatedDecryptionFilter</a>, <a class="el" href="class_authenticated_encryption_filter.html#a061422f8897f1a9545ba47f7ff0d8d5b">AuthenticatedEncryptionFilter</a>, <a class="el" href="class_channel_switch.html#a19e244d0593c91190858739b3240489c">ChannelSwitch</a>, <a class="el" href="class_equality_comparison_filter.html#af6f119a0a2e8a91c46676fc4f1eeeddc">EqualityComparisonFilter</a>, and <a class="el" href="class_raw_i_d_a.html#ade3964428df9a1d872926db0cc2e1251">RawIDA</a>.</p>

</div>
</div>
<a id="ad3e9efe4c59093c330d287140fcfbdd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e9efe4c59093c330d287140fcfbdd9">&#9670;&nbsp;</a></span>ChannelPutMessageEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::ChannelPutMessageEnd </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>inString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propagation</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input multiple bytes for processing and signal the end of a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to process the data. </td></tr>
    <tr><td class="paramname">inString</td><td>the byte buffer to process </td></tr>
    <tr><td class="paramname">length</td><td>the size of the string, in bytes </td></tr>
    <tr><td class="paramname">propagation</td><td>the number of attached transformations the <a class="el" href="class_buffered_transformation.html#ad3e9efe4c59093c330d287140fcfbdd9" title="Input multiple bytes for processing and signal the end of a message. ">ChannelPutMessageEnd()</a> signal should be passed </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that remain in the block (i.e., bytes not processed)</dd></dl>
<p>propagation count includes this object. Setting propagation to <code>1</code> means this object only. Setting propagation to <code>-1</code> means unlimited propagation. </p>

</div>
</div>
<a id="a3dc27692b14108ed057beb4db67fed2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc27692b14108ed057beb4db67fed2f">&#9670;&nbsp;</a></span>ChannelPutModifiable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::ChannelPutModifiable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>inString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input multiple bytes that may be modified by callee on a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to process the data. </td></tr>
    <tr><td class="paramname">inString</td><td>the byte buffer to process </td></tr>
    <tr><td class="paramname">length</td><td>the size of the string, in bytes </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 indicates all bytes were processed during the call. Non-0 indicates the number of bytes that were <em>not</em> processed. </dd></dl>

</div>
</div>
<a id="add2a8b1b88a881edf8bebe089438fc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2a8b1b88a881edf8bebe089438fc66">&#9670;&nbsp;</a></span>ChannelPutModifiable2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::ChannelPutModifiable2 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>inString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>messageEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input multiple bytes that may be modified by callee on a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to process the data </td></tr>
    <tr><td class="paramname">inString</td><td>the byte buffer to process </td></tr>
    <tr><td class="paramname">length</td><td>the size of the string, in bytes </td></tr>
    <tr><td class="paramname">messageEnd</td><td>means how many filters to signal <a class="el" href="class_buffered_transformation.html#a20ae0ef2e4ff338b43849e541e9b940f" title="Signals the end of messages to the object. ">MessageEnd()</a> to, including this one </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that remain in the block (i.e., bytes not processed) </dd></dl>

<p>Reimplemented in <a class="el" href="class_output_proxy.html#a7d01981113dfb1543b7e04b96522cc1e">OutputProxy</a>, <a class="el" href="class_redirector.html#aa39d3ce8654aede6c9473129125dffc7">Redirector</a>, and <a class="el" href="class_channel_switch.html#a914398ac6126fb975393a033ba3bd2d9">ChannelSwitch</a>.</p>

</div>
</div>
<a id="aa1bca66c16e0e52793059b41353964bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1bca66c16e0e52793059b41353964bd">&#9670;&nbsp;</a></span>ChannelPutWord16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::ChannelPutWord16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word16&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Input a 16-bit word for processing on a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to process the data. </td></tr>
    <tr><td class="paramname">value</td><td>the 16-bit value to be processed. </td></tr>
    <tr><td class="paramname">order</td><td>the ByteOrder of the value to be processed. </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 indicates all bytes were processed during the call. Non-0 indicates the number of bytes that were <em>not</em> processed. </dd></dl>

</div>
</div>
<a id="acb06216012d6c40609db092952afcf3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb06216012d6c40609db092952afcf3f">&#9670;&nbsp;</a></span>ChannelPutWord32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::ChannelPutWord32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Input a 32-bit word for processing on a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to process the data. </td></tr>
    <tr><td class="paramname">value</td><td>the 32-bit value to be processed. </td></tr>
    <tr><td class="paramname">order</td><td>the ByteOrder of the value to be processed. </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 indicates all bytes were processed during the call. Non-0 indicates the number of bytes that were <em>not</em> processed. </dd></dl>

</div>
</div>
<a id="a18893c1bd5eee9263022f72d4ac992ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18893c1bd5eee9263022f72d4ac992ad">&#9670;&nbsp;</a></span>CopyAllTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BufferedTransformation::CopyAllTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em> = <code><a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy messages from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>the destination <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a> </td></tr>
    <tr><td class="paramname">channel</td><td>the channel on which the transfer should occur</td></tr>
  </table>
  </dd>
</dl>
<p>CopyAllTo copies messages from this object and copies them to the destination. </p>

</div>
</div>
<a id="a2d4b2099b75141367e96ce60c6eb939f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4b2099b75141367e96ce60c6eb939f">&#9670;&nbsp;</a></span>CopyMessagesTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int BufferedTransformation::CopyMessagesTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em> = <code>UINT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em> = <code><a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy messages from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>the destination <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a> </td></tr>
    <tr><td class="paramname">count</td><td>the number of messages to transfer </td></tr>
    <tr><td class="paramname">channel</td><td>the channel on which the transfer should occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that remain in the current transfer block (i.e., bytes not transferred)</dd></dl>
<p>CopyMessagesTo copies messages from this object and copies them to the destination. If all bytes are not transferred for a message, then processing stops and the number of remaining bytes is returned. <a class="el" href="class_buffered_transformation.html#a2d4b2099b75141367e96ce60c6eb939f" title="Copy messages from this object to another BufferedTransformation. ">CopyMessagesTo()</a> does not proceed to the next message.</p>
<p>A return value of 0 indicates all messages were successfully copied. </p>

</div>
</div>
<a id="a7ac245e7a90e75e51482ce4421969616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac245e7a90e75e51482ce4421969616">&#9670;&nbsp;</a></span>CopyRangeTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lword BufferedTransformation::CopyRangeTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lword&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lword&#160;</td>
          <td class="paramname"><em>copyMax</em> = <code>LWORD_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em> = <code><a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy bytes from this object using an index to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>the destination <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a> </td></tr>
    <tr><td class="paramname">position</td><td>the 0-based index of the byte stream to begin the copying </td></tr>
    <tr><td class="paramname">copyMax</td><td>the number of bytes to copy </td></tr>
    <tr><td class="paramname">channel</td><td>the channel on which the transfer should occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes copied during the call.</dd></dl>
<p>CopyTo copies bytes from this object to the destination. The bytes remain in this object. Copying begins at the index position in the current stream, and not from an absolute position in the stream.</p>
<p>The function returns the new position in the stream after transferring the bytes starting at the index. </p>

</div>
</div>
<a id="a7f90ef36f633c97c1ae519b800527d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f90ef36f633c97c1ae519b800527d8e">&#9670;&nbsp;</a></span>CopyRangeTo2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t BufferedTransformation::CopyRangeTo2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lword &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lword&#160;</td>
          <td class="paramname"><em>end</em> = <code>LWORD_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em> = <code><a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy bytes from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>the destination <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a> </td></tr>
    <tr><td class="paramname">begin</td><td>the 0-based index of the first byte to copy in the stream </td></tr>
    <tr><td class="paramname">end</td><td>the 0-based index of the last byte to copy in the stream </td></tr>
    <tr><td class="paramname">channel</td><td>the channel on which the transfer should occur </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that remain in the copy block (i.e., bytes not copied)</dd></dl>
<p>CopyRangeTo2 copies bytes from this object to the destination. The bytes are not removed from this object. Copying begins at the index position in the current stream, and not from an absolute position in the stream.</p>
<p>begin is an <em>IN</em> and <em>OUT</em> parameter. When the call is made, begin is the starting position of the copy. When the call returns, begin is the position of the first byte that was <em>not</em> copied (which may be different than end). begin can be used for subsequent calls to <a class="el" href="class_buffered_transformation.html#a7f90ef36f633c97c1ae519b800527d8e" title="Copy bytes from this object to another BufferedTransformation. ">CopyRangeTo2()</a>. </p>

<p>Implemented in <a class="el" href="class_null_store.html#a392d1f43c190dd48e145ddbc3c7ffba3">NullStore</a>, <a class="el" href="class_random_number_store.html#ab1007214c6ed0398440bb38b4db47d68">RandomNumberStore</a>, <a class="el" href="class_string_store.html#a1272eeca9a2496019bb524faa23ac557">StringStore</a>, <a class="el" href="class_sink.html#aed64e6f6c263c9f08fa2fc5febfb9d73">Sink</a>, <a class="el" href="class_b_e_r_general_decoder.html#a6810c7cb5628b2728195667c378af6f1">BERGeneralDecoder</a>, <a class="el" href="class_byte_queue_1_1_walker.html#a5491cc2e63a737cecbcc2d1e8333ee31">ByteQueue::Walker</a>, <a class="el" href="class_filter.html#a9cde2dec371b3074cb4ed92d57ef1f24">Filter</a>, <a class="el" href="class_file_store.html#a48faf8415120153e2c6db2379d7b2ad2">FileStore</a>, <a class="el" href="class_byte_queue.html#aeb91427c87efe486fcacb5aa726ef6ed">ByteQueue</a>, and <a class="el" href="class_message_queue.html#a71f463f622cb8e097e34aa0016303a40">MessageQueue</a>.</p>

</div>
</div>
<a id="a7693f056b01bc4feadd8a794fba2d30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7693f056b01bc4feadd8a794fba2d30a">&#9670;&nbsp;</a></span>CopyTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lword BufferedTransformation::CopyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lword&#160;</td>
          <td class="paramname"><em>copyMax</em> = <code>LWORD_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em> = <code><a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy copyMax bytes of the buffered output to target as input </p>
<p>Copy bytes from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>the destination <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a> </td></tr>
    <tr><td class="paramname">copyMax</td><td>the number of bytes to copy </td></tr>
    <tr><td class="paramname">channel</td><td>the channel on which the transfer should occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes copied during the call.</dd></dl>
<p>CopyTo copies bytes from this object to the destination. The bytes are not removed from this object.</p>
<p>The function always returns copyMax. If an accurate count is needed, then use <a class="el" href="class_buffered_transformation.html#a7f90ef36f633c97c1ae519b800527d8e" title="Copy bytes from this object to another BufferedTransformation. ">CopyRangeTo2()</a>. </p>

</div>
</div>
<a id="af390325c959c3d6a2c03a447d6cd469d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af390325c959c3d6a2c03a447d6cd469d">&#9670;&nbsp;</a></span>CreatePutSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual byte* BufferedTransformation::CreatePutSpace </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request space which can be written into by the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the requested size of the buffer</td></tr>
  </table>
  </dd>
</dl>
<p>The purpose of this method is to help avoid extra memory allocations.</p>
<p>size is an <em>IN</em> and <em>OUT</em> parameter and used as a hint. When the call is made, size is the requested size of the buffer. When the call returns, size is the size of the array returned to the caller.</p>
<p>The base class implementation sets size to 0 and returns NULL. </p><dl class="section note"><dt>Note</dt><dd>Some objects, like <a class="el" href="class_array_sink.html" title="Copy input to a memory buffer. ">ArraySink</a>, cannot create a space because its fixed. In the case of an <a class="el" href="class_array_sink.html" title="Copy input to a memory buffer. ">ArraySink</a>, the pointer to the array is returned and the size is remaining size. </dd></dl>

<p>Reimplemented in <a class="el" href="class_array_xor_sink.html#a39567ce27137cc06ed9a2b0a1c834f01">ArrayXorSink</a>, <a class="el" href="class_array_sink.html#a535e57a894542c088131bc84955c475b">ArraySink</a>, <a class="el" href="class_output_proxy.html#ae0400c5e91f8d8c50e2b4da7d15bf646">OutputProxy</a>, <a class="el" href="class_redirector.html#a09afd32c22cc2d4ef9ddc8650b8657f5">Redirector</a>, <a class="el" href="class_hash_filter.html#a5c2f3a90ced66c835969ce1aa235b63e">HashFilter</a>, <a class="el" href="class_meter_filter.html#a49d92192dcbd3366ff0576159ea62e9d">MeterFilter</a>, <a class="el" href="class_multichannel.html#af0b0eb15ec27d19c93a1455d948c578e">Multichannel&lt; Filter &gt;</a>, <a class="el" href="class_multichannel.html#af0b0eb15ec27d19c93a1455d948c578e">Multichannel&lt; Sink &gt;</a>, and <a class="el" href="class_byte_queue.html#ae6b49917c3217c5e3b8dd71d40498e5f">ByteQueue</a>.</p>

</div>
</div>
<a id="a0dc1428070dce0ce5651d775593ccce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc1428070dce0ce5651d775593ccce0">&#9670;&nbsp;</a></span>DecrementPropagation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int BufferedTransformation::DecrementPropagation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propagation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrements the propagation count while clamping at 0. </p>
<dl class="section return"><dt>Returns</dt><dd>the decremented propagation or 0 </dd></dl>

</div>
</div>
<a id="a7d101fec1e0eafaacb9458804354c9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d101fec1e0eafaacb9458804354c9c8">&#9670;&nbsp;</a></span>Detach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void BufferedTransformation::Detach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> *&#160;</td>
          <td class="paramname"><em>newAttachment</em> = <code>NULLPTR</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the current attachment chain and attach a new one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newAttachment</td><td>the new <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a> to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_not_implemented.html" title="A method was called which was not implemented. ">NotImplemented</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_buffered_transformation.html#a7d101fec1e0eafaacb9458804354c9c8" title="Delete the current attachment chain and attach a new one. ">Detach()</a> deletes the current attachment chain and replace it with an optional newAttachment</p>
<p>If a derived class does not override <a class="el" href="class_buffered_transformation.html#a7d101fec1e0eafaacb9458804354c9c8" title="Delete the current attachment chain and attach a new one. ">Detach()</a>, then the base class throws <a class="el" href="class_not_implemented.html" title="A method was called which was not implemented. ">NotImplemented</a>. </p>

<p>Reimplemented in <a class="el" href="class_filter.html#a8cb2a78a83a0931570e65da3c74d4127">Filter</a>.</p>

</div>
</div>
<a id="a8a62b1b6c8f310363f32b05b20c306eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a62b1b6c8f310363f32b05b20c306eb">&#9670;&nbsp;</a></span>Flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BufferedTransformation::Flush </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hardFlush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propagation</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush buffered input and/or output, with signal propagation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hardFlush</td><td>is used to indicate whether all data should be flushed </td></tr>
    <tr><td class="paramname">propagation</td><td>the number of attached transformations the <a class="el" href="class_buffered_transformation.html#a8a62b1b6c8f310363f32b05b20c306eb" title="Flush buffered input and/or output, with signal propagation. ">Flush()</a> signal should be passed </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input</td></tr>
  </table>
  </dd>
</dl>
<p>propagation count includes this object. Setting propagation to <code>1</code> means this object only. Setting propagation to <code>-1</code> means unlimited propagation. </p><dl class="section note"><dt>Note</dt><dd>Hard flushes must be used with care. It means try to process and output everything, even if there may not be enough data to complete the action. For example, hard flushing a <a class="el" href="class_hex_decoder.html" title="Decode base 16 data back to bytes. ">HexDecoder</a> would cause an error if you do it after inputing an odd number of hex encoded characters. </dd>
<dd>
For some types of filters, like <a class="el" href="class_zlib_decompressor.html" title="ZLIB Decompressor (RFC 1950) ">ZlibDecompressor</a>, hard flushes can only be done at "synchronization points". These synchronization points are positions in the data stream that are created by hard flushes on the corresponding reverse filters, in this example <a class="el" href="class_zlib_compressor.html" title="ZLIB Compressor (RFC 1950) ">ZlibCompressor</a>. This is useful when zlib compressed data is moved across a network in packets and compression state is preserved across packets, as in the SSH2 protocol. </dd></dl>

<p>Reimplemented in <a class="el" href="class_output_proxy.html#aa6c68d78790266c60fa8b27176fbf969">OutputProxy</a>, <a class="el" href="class_redirector.html#a201243b803642ebfd392579953e75e92">Redirector</a>, <a class="el" href="class_multichannel.html#ae3e6176eb5f0de2857aa7066272c07ce">Multichannel&lt; Filter &gt;</a>, <a class="el" href="class_multichannel.html#ae3e6176eb5f0de2857aa7066272c07ce">Multichannel&lt; Sink &gt;</a>, <a class="el" href="class_custom_flush_propagation.html#ac0faa3bd64279e9ad1912cdcdff446ef">CustomFlushPropagation&lt; Filter &gt;</a>, <a class="el" href="class_custom_flush_propagation.html#ac0faa3bd64279e9ad1912cdcdff446ef">CustomFlushPropagation&lt; Sink &gt;</a>, <a class="el" href="class_information_dispersal.html#aa348e2dd4609c563196f89e1cf2ad35c">InformationDispersal</a>, <a class="el" href="class_secret_sharing.html#a670b6f5ba7ee9e1f029cd199f6722bb6">SecretSharing</a>, and <a class="el" href="class_filter.html#ad845deb5113d2bd04d109c05abfd3098">Filter</a>.</p>

</div>
</div>
<a id="a9e1ad913c8fe697d269f408a7d5928fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1ad913c8fe697d269f408a7d5928fc">&#9670;&nbsp;</a></span>Get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::Get </td>
          <td>(</td>
          <td class="paramtype">byte &amp;&#160;</td>
          <td class="paramname"><em>outByte</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a 8-bit byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outByte</td><td>the 8-bit value to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes consumed during the call.</dd></dl>
<p>Use the return value of Get to detect short reads. </p>

<p>Reimplemented in <a class="el" href="class_byte_queue_1_1_walker.html#a1577996016d4fc5e644b86eb1a4f1660">ByteQueue::Walker</a>, and <a class="el" href="class_byte_queue.html#a19413e3aa72b749e3771d617e8eca632">ByteQueue</a>.</p>

</div>
</div>
<a id="a0a6f18a871720453e1791c64f0461a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6f18a871720453e1791c64f0461a9f">&#9670;&nbsp;</a></span>Get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::Get </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>outString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>getMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a block of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outString</td><td>a block of bytes </td></tr>
    <tr><td class="paramname">getMax</td><td>the number of bytes to Get </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes consumed during the call.</dd></dl>
<p>Use the return value of Get to detect short reads. </p>

<p>Reimplemented in <a class="el" href="class_byte_queue_1_1_walker.html#a940623c7bff90ab48f1534352675f92b">ByteQueue::Walker</a>, and <a class="el" href="class_byte_queue.html#a933457ad0a5a34fb5e7dc71b2a92c3a7">ByteQueue</a>.</p>

</div>
</div>
<a id="a76a32fc46e74c3c509934a11b8f5fec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a32fc46e74c3c509934a11b8f5fec7">&#9670;&nbsp;</a></span>GetAutoSignalPropagation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int BufferedTransformation::GetAutoSignalPropagation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve automatic signal propagation value. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of attached transformations the signal is propagated to. 0 indicates the signal is only witnessed by this object </dd></dl>

<p>Reimplemented in <a class="el" href="class_source_template.html#aeb0d3d0a6e3f56d88e9dabcec2e096f9">SourceTemplate&lt; T &gt;</a>, <a class="el" href="class_source_template.html#aeb0d3d0a6e3f56d88e9dabcec2e096f9">SourceTemplate&lt; FileStore &gt;</a>, <a class="el" href="class_source_template.html#aeb0d3d0a6e3f56d88e9dabcec2e096f9">SourceTemplate&lt; RandomNumberStore &gt;</a>, and <a class="el" href="class_source_template.html#aeb0d3d0a6e3f56d88e9dabcec2e096f9">SourceTemplate&lt; StringStore &gt;</a>.</p>

</div>
</div>
<a id="a8dc8562950fd563f7c62d1f1e5ec6b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc8562950fd563f7c62d1f1e5ec6b1e">&#9670;&nbsp;</a></span>GetNextMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BufferedTransformation::GetNextMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start retrieving the next message. </p>
<dl class="section return"><dt>Returns</dt><dd>true if a message is ready for retrieval</dd></dl>
<p><a class="el" href="class_buffered_transformation.html#a8dc8562950fd563f7c62d1f1e5ec6b1e" title="Start retrieving the next message. ">GetNextMessage()</a> returns true if a message is ready for retrieval; false if no more messages exist or this message is not completely retrieved. </p>

<p>Reimplemented in <a class="el" href="class_store.html#a5f578b4a2da5371a8a4b80a038a2d5ea">Store</a>, and <a class="el" href="class_message_queue.html#a540da279953a13541a65c271888e27b7">MessageQueue</a>.</p>

</div>
</div>
<a id="aeb36a158b63cfd54acbada1a3699598c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb36a158b63cfd54acbada1a3699598c">&#9670;&nbsp;</a></span>GetNextMessageSeries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool BufferedTransformation::GetNextMessageSeries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the next message in a series. </p>
<dl class="section return"><dt>Returns</dt><dd>true if a message was retreved, false otherwise</dd></dl>
<p>Internally, the base class implementation returns false. </p>

</div>
</div>
<a id="a127ccd1793fdda6548cd1295f848d0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127ccd1793fdda6548cd1295f848d0f7">&#9670;&nbsp;</a></span>GetWaitObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BufferedTransformation::GetWaitObjects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wait_object_container.html">WaitObjectContainer</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_call_stack.html">CallStack</a> const &amp;&#160;</td>
          <td class="paramname"><em>callStack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves waitable objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>the wait container to receive the references to the objects </td></tr>
    <tr><td class="paramname">callStack</td><td><a class="el" href="class_call_stack.html">CallStack()</a> object used to select waitable objects</td></tr>
  </table>
  </dd>
</dl>
<p>GetWaitObjects is usually called in one of two ways. First, it can be called like <code>something.GetWaitObjects(c, <a class="el" href="class_call_stack.html">CallStack</a>("my func after X", 0));</code>. Second, if in an outer <a class="el" href="class_buffered_transformation.html#a127ccd1793fdda6548cd1295f848d0f7" title="Retrieves waitable objects. ">GetWaitObjects()</a> method that itself takes a callStack parameter, it can be called like <code>innerThing.GetWaitObjects(c, <a class="el" href="class_call_stack.html">CallStack</a>("MyClass::GetWaitObjects at X", &amp;callStack));</code>. </p>

<p>Implements <a class="el" href="class_waitable.html#a97155f28db33d3dacc69dc453a01609a">Waitable</a>.</p>

<p>Reimplemented in <a class="el" href="class_redirector.html#ac0dc5f63f7a57af37f819aa9251a78bf">Redirector</a>.</p>

</div>
</div>
<a id="a1ac50bcb2d279c3c6aef6858dab3eeb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac50bcb2d279c3c6aef6858dab3eeb7">&#9670;&nbsp;</a></span>GetWord16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::GetWord16 </td>
          <td>(</td>
          <td class="paramtype">word16 &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a 16-bit word. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 16-bit value to be retrieved </td></tr>
    <tr><td class="paramname">order</td><td>the ByteOrder of the value to be processed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes consumed during the call.</dd></dl>
<p>Use the return value of <a class="el" href="class_buffered_transformation.html#a1ac50bcb2d279c3c6aef6858dab3eeb7" title="Retrieve a 16-bit word. ">GetWord16()</a> to detect short reads. </p>

</div>
</div>
<a id="a69c064d931db3a8631c1138827d67e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c064d931db3a8631c1138827d67e2f">&#9670;&nbsp;</a></span>GetWord32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::GetWord32 </td>
          <td>(</td>
          <td class="paramtype">word32 &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a 32-bit word. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 32-bit value to be retrieved </td></tr>
    <tr><td class="paramname">order</td><td>the ByteOrder of the value to be processed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes consumed during the call.</dd></dl>
<p>Use the return value of <a class="el" href="class_buffered_transformation.html#a1ac50bcb2d279c3c6aef6858dab3eeb7" title="Retrieve a 16-bit word. ">GetWord16()</a> to detect short reads. </p>

</div>
</div>
<a id="a0dd5456c06e0e47d901e8055b50df929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd5456c06e0e47d901e8055b50df929">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BufferedTransformation::Initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_name_value_pairs.html">NameValuePairs</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em> = <code><a class="el" href="cryptlib_8h.html#aa486a199e3e80fed67fb9a1992ca91e0">g_nullNameValuePairs</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propagation</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize or reinitialize this object, with signal propagation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>a set of <a class="el" href="class_name_value_pairs.html" title="Interface for retrieving values given their names. ">NameValuePairs</a> to initialize or reinitialize this object </td></tr>
    <tr><td class="paramname">propagation</td><td>the number of attached transformations the <a class="el" href="class_buffered_transformation.html#a0dd5456c06e0e47d901e8055b50df929" title="Initialize or reinitialize this object, with signal propagation. ">Initialize()</a> signal should be passed</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_buffered_transformation.html#a0dd5456c06e0e47d901e8055b50df929" title="Initialize or reinitialize this object, with signal propagation. ">Initialize()</a> is used to initialize or reinitialize an object using a variable number of arbitrarily typed arguments. The function avoids the need for multiple constructors providing all possible combintations of configurable parameters.</p>
<p>propagation count includes this object. Setting propagation to <code>1</code> means this object only. Setting propagation to <code>-1</code> means unlimited propagation. </p>

<p>Reimplemented in <a class="el" href="class_output_proxy.html#a48d4fa2095a31780f6bc0b37737de49f">OutputProxy</a>, <a class="el" href="class_redirector.html#af5fe25d9b6e17ec878e8f2b188702736">Redirector</a>, <a class="el" href="class_custom_signal_propagation.html#a74fd5f3bb893d25f73f5bbab2c2d89ef">CustomSignalPropagation&lt; Sink &gt;</a>, and <a class="el" href="class_filter.html#a0c011bdc71755b373292e7a722e9e332">Filter</a>.</p>

</div>
</div>
<a id="a68044dc8d57bc02edee1ce02b459a63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68044dc8d57bc02edee1ce02b459a63d">&#9670;&nbsp;</a></span>IsolatedFlush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool BufferedTransformation::IsolatedFlush </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hardFlush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flushes data buffered by this object, without signal propagation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hardFlush</td><td>indicates whether all data should be flushed </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>hardFlush must be used with care </dd></dl>

<p>Implemented in <a class="el" href="class_proxy_filter.html#ae5d15b0c5bcc601a58dde22e01ce9b79">ProxyFilter</a>, <a class="el" href="class_filter_with_buffered_input.html#a4261e0491864a31738cf53b3f9343806">FilterWithBufferedInput</a>, <a class="el" href="class_file_sink.html#af6485914da76e0374ad93d79da10030f">FileSink</a>, <a class="el" href="class_deflator.html#a4337716743ff155dc5321843eda29d00">Deflator</a>, <a class="el" href="class_inflator.html#affacf5ce529cc11dc72e5b46ef42d9f7">Inflator</a>, and <a class="el" href="class_message_queue.html#adf7c0e8cc64279572e4bfc282bcdba78">MessageQueue</a>.</p>

</div>
</div>
<a id="a7bb05ac3b6302e2ab994586d526fa804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb05ac3b6302e2ab994586d526fa804">&#9670;&nbsp;</a></span>IsolatedInitialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void BufferedTransformation::IsolatedInitialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_name_value_pairs.html">NameValuePairs</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize or reinitialize this object, without signal propagation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>a set of <a class="el" href="class_name_value_pairs.html" title="Interface for retrieving values given their names. ">NameValuePairs</a> to initialize this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_not_implemented.html" title="A method was called which was not implemented. ">NotImplemented</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_buffered_transformation.html#a7bb05ac3b6302e2ab994586d526fa804" title="Initialize or reinitialize this object, without signal propagation. ">IsolatedInitialize()</a> is used to initialize or reinitialize an object using a variable number of arbitrarily typed arguments. The function avoids the need for multiple constructors providing all possible combintations of configurable parameters.</p>
<p><a class="el" href="class_buffered_transformation.html#a7bb05ac3b6302e2ab994586d526fa804" title="Initialize or reinitialize this object, without signal propagation. ">IsolatedInitialize()</a> does not call <a class="el" href="class_buffered_transformation.html#a0dd5456c06e0e47d901e8055b50df929" title="Initialize or reinitialize this object, with signal propagation. ">Initialize()</a> on attached transformations. If initialization should be propagated, then use the <a class="el" href="class_buffered_transformation.html#a0dd5456c06e0e47d901e8055b50df929" title="Initialize or reinitialize this object, with signal propagation. ">Initialize()</a> function.</p>
<p>If a derived class does not override <a class="el" href="class_buffered_transformation.html#a7bb05ac3b6302e2ab994586d526fa804" title="Initialize or reinitialize this object, without signal propagation. ">IsolatedInitialize()</a>, then the base class throws <a class="el" href="class_not_implemented.html" title="A method was called which was not implemented. ">NotImplemented</a>. </p>

<p>Reimplemented in <a class="el" href="class_source_template.html#ae0f81a7cfeb0cc6307e141907b62c5a3">SourceTemplate&lt; T &gt;</a>, <a class="el" href="class_source_template.html#ae0f81a7cfeb0cc6307e141907b62c5a3">SourceTemplate&lt; FileStore &gt;</a>, <a class="el" href="class_source_template.html#ae0f81a7cfeb0cc6307e141907b62c5a3">SourceTemplate&lt; RandomNumberStore &gt;</a>, <a class="el" href="class_source_template.html#ae0f81a7cfeb0cc6307e141907b62c5a3">SourceTemplate&lt; StringStore &gt;</a>, <a class="el" href="class_array_sink.html#a0b677032fc5455f0ad134d4271ac40c3">ArraySink</a>, <a class="el" href="class_random_number_sink.html#ad9eb1681d33e03ebf6ef43dc70299c9e">RandomNumberSink</a>, <a class="el" href="class_string_sink_template.html#aca537f96a83a3006a32a4848af2f47f5">StringSinkTemplate&lt; T &gt;</a>, <a class="el" href="class_signer_filter.html#adf4aaa798c16e2ee90bbd39b876df717">SignerFilter</a>, <a class="el" href="class_authenticated_encryption_filter.html#aad275712b531d24e3ac4d332d46f1dd4">AuthenticatedEncryptionFilter</a>, <a class="el" href="class_hash_filter.html#a950c5cc22d2aa101e731401b10ff2be4">HashFilter</a>, <a class="el" href="class_filter_with_input_queue.html#a94b46e509ab5cb9dbd676c41ea346107">FilterWithInputQueue</a>, <a class="el" href="class_bit_bucket.html#ab284f7730a9c195e00b9d8b61efc8105">BitBucket</a>, <a class="el" href="class_filter_with_buffered_input.html#ae97be71708e0020167e5c08856fd3f3b">FilterWithBufferedInput</a>, <a class="el" href="class_store.html#a47bfecef2abe22b090935cfab6f19f89">Store</a>, <a class="el" href="class_meter_filter.html#a141a6f8b09072847dbdd6a3f0f33f865">MeterFilter</a>, <a class="el" href="class_padding_remover.html#a069c4ebead6f2ed5393628b039b1688f">PaddingRemover</a>, <a class="el" href="class_file_sink.html#add89bb9890b60ce429ba590941099790">FileSink</a>, <a class="el" href="class_information_recovery.html#addaa1b3de9087ae7be368086fc1108a5">InformationRecovery</a>, <a class="el" href="class_base64_u_r_l_decoder.html#a77dac8fba6e9c3992900e51b4887524b">Base64URLDecoder</a>, <a class="el" href="class_grouper.html#af44beea74b2140892d24aa635a7f3dcd">Grouper</a>, <a class="el" href="class_information_dispersal.html#a3901bdfb5959c2ee901bd3a5fe1c161a">InformationDispersal</a>, <a class="el" href="class_base64_u_r_l_encoder.html#a777ab49eb48fafc75b0f534ef79cbf19">Base64URLEncoder</a>, <a class="el" href="class_deflator.html#ac9f545b8062a7e822e537364ef422111">Deflator</a>, <a class="el" href="class_inflator.html#a498b0cb5eaf4f73715f2608c7f3c31ab">Inflator</a>, <a class="el" href="class_channel_switch.html#af663620f334464f987001187102bbb49">ChannelSwitch</a>, <a class="el" href="class_secret_recovery.html#aac4881f4805b1ff8c662348d61a6d422">SecretRecovery</a>, <a class="el" href="class_byte_queue_1_1_walker.html#ab74b6b33c01b0221a24e1ba17ac7a374">ByteQueue::Walker</a>, <a class="el" href="class_base32_decoder.html#a4b013b73a5fa3038c9ac654cd0aceb40">Base32Decoder</a>, <a class="el" href="class_base_n___decoder.html#a7c82c37a6626042f2e0eb65307e039b7">BaseN_Decoder</a>, <a class="el" href="class_base64_decoder.html#a78677d90f12a96b6239f42c7faa14cc8">Base64Decoder</a>, <a class="el" href="class_secret_sharing.html#a9bd87681fc1b766ca5a0c96a4a54a813">SecretSharing</a>, <a class="el" href="class_gzip.html#a98817b6faafa1b906af34b6aa7565bcc">Gzip</a>, <a class="el" href="class_base32_encoder.html#a51672a74492c2dd31c7cada0471c6326">Base32Encoder</a>, <a class="el" href="class_base64_encoder.html#afc7466a518ec03be6d36696df3ff50a6">Base64Encoder</a>, <a class="el" href="class_base_n___encoder.html#a3489c960fafc6ae65a8749133646901b">BaseN_Encoder</a>, <a class="el" href="class_hex_decoder.html#a37fb07268b170d7a00c741e012278145">HexDecoder</a>, <a class="el" href="class_byte_queue.html#a7e576bc7629bd0947eb098ad23b0d675">ByteQueue</a>, <a class="el" href="class_raw_i_d_a.html#a80b961ed9d9ba16267e3a2db70649736">RawIDA</a>, <a class="el" href="class_hex_encoder.html#a082ae0bc1d202336421e5597792ee2d7">HexEncoder</a>, and <a class="el" href="class_message_queue.html#a26b8baf32ac98064caf0696fc37dcacf">MessageQueue</a>.</p>

</div>
</div>
<a id="aaf09f0cd6dbd022539a9ac5c316d4984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf09f0cd6dbd022539a9ac5c316d4984">&#9670;&nbsp;</a></span>IsolatedMessageSeriesEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool BufferedTransformation::IsolatedMessageSeriesEnd </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the end of a series of messages, without signal propagation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when completing the processing on the current series of messages </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_meter_filter.html#aa3b923710e4ed83fb4980cb53504a521">MeterFilter</a>, and <a class="el" href="class_message_queue.html#a574f29031f2d8ae02e7ff4a03e5db8bf">MessageQueue</a>.</p>

</div>
</div>
<a id="a30b2076bce5fb29e992b6457485c67c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b2076bce5fb29e992b6457485c67c2">&#9670;&nbsp;</a></span>MaxRetrievable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lword BufferedTransformation::MaxRetrievable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the number of bytes ready for retrieval. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes ready for retrieval</dd></dl>
<p>All retrieval functions return the actual number of bytes retrieved, which is the lesser of the request number and <a class="el" href="class_buffered_transformation.html#a30b2076bce5fb29e992b6457485c67c2" title="Provides the number of bytes ready for retrieval. ">MaxRetrievable()</a> </p>

<p>Reimplemented in <a class="el" href="class_null_store.html#ae34e25265289f889c8ea2e2bf6dda275">NullStore</a>, <a class="el" href="class_random_number_store.html#a32bb1cb70f9724ac88330fe516d7b076">RandomNumberStore</a>, <a class="el" href="class_byte_queue_1_1_walker.html#a7e3e18155c288996a2243ced4c87c6b5">ByteQueue::Walker</a>, <a class="el" href="class_file_store.html#a27e29d3d04ddf2888d968327b26d9c88">FileStore</a>, <a class="el" href="class_message_queue.html#afc8f0d4551de7b0a19d7747420015d1c">MessageQueue</a>, and <a class="el" href="class_byte_queue.html#aad7436088ce8a852e9e95d291590a9f9">ByteQueue</a>.</p>

</div>
</div>
<a id="a20ae0ef2e4ff338b43849e541e9b940f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ae0ef2e4ff338b43849e541e9b940f">&#9670;&nbsp;</a></span>MessageEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BufferedTransformation::MessageEnd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propagation</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signals the end of messages to the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propagation</td><td>the number of attached transformations the <a class="el" href="class_buffered_transformation.html#a20ae0ef2e4ff338b43849e541e9b940f" title="Signals the end of messages to the object. ">MessageEnd()</a> signal should be passed </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input</td></tr>
  </table>
  </dd>
</dl>
<p>propagation count includes this object. Setting propagation to <code>1</code> means this object only. Setting propagation to <code>-1</code> means unlimited propagation. </p>

</div>
</div>
<a id="aae4c5ae024419e31bfa0c24eb35b24c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4c5ae024419e31bfa0c24eb35b24c2">&#9670;&nbsp;</a></span>MessageSeriesEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BufferedTransformation::MessageSeriesEnd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propagation</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the end of a series of messages, with signal propagation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propagation</td><td>the number of attached transformations the <a class="el" href="class_buffered_transformation.html#aae4c5ae024419e31bfa0c24eb35b24c2" title="Marks the end of a series of messages, with signal propagation. ">MessageSeriesEnd()</a> signal should be passed </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input</td></tr>
  </table>
  </dd>
</dl>
<p>Each object that receives the signal will perform its processing, decrement propagation, and then pass the signal on to attached transformations if the value is not 0.</p>
<p>propagation count includes this object. Setting propagation to <code>1</code> means this object only. Setting propagation to <code>-1</code> means unlimited propagation. </p><dl class="section note"><dt>Note</dt><dd>There should be a <a class="el" href="class_buffered_transformation.html#a20ae0ef2e4ff338b43849e541e9b940f" title="Signals the end of messages to the object. ">MessageEnd()</a> immediately before <a class="el" href="class_buffered_transformation.html#aae4c5ae024419e31bfa0c24eb35b24c2" title="Marks the end of a series of messages, with signal propagation. ">MessageSeriesEnd()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="class_output_proxy.html#aecf5c216c060f2e6adfeb4019e6ad797">OutputProxy</a>, <a class="el" href="class_redirector.html#a34c42c1730d031f486e5d285c6dc3314">Redirector</a>, <a class="el" href="class_multichannel.html#a18b9b1cc4e6d2649214c62e447052db9">Multichannel&lt; Filter &gt;</a>, <a class="el" href="class_multichannel.html#a18b9b1cc4e6d2649214c62e447052db9">Multichannel&lt; Sink &gt;</a>, and <a class="el" href="class_filter.html#aa42c62587dda61266ac8195d9c9edb47">Filter</a>.</p>

</div>
</div>
<a id="a56bcbb4306a9c04cda838f96e85a2116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56bcbb4306a9c04cda838f96e85a2116">&#9670;&nbsp;</a></span>NumberOfMessages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int BufferedTransformation::NumberOfMessages </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the number of meesages processed by this object. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of meesages processed by this object</dd></dl>
<p>NumberOfMessages returns number of times <a class="el" href="class_buffered_transformation.html#a20ae0ef2e4ff338b43849e541e9b940f" title="Signals the end of messages to the object. ">MessageEnd()</a> has been received minus messages retrieved or skipped </p>

<p>Reimplemented in <a class="el" href="class_store.html#a671fcd19428a776aa08d767a97ed116a">Store</a>, and <a class="el" href="class_message_queue.html#aa4b2a11a888efea5f9ca388d8a730bba">MessageQueue</a>.</p>

</div>
</div>
<a id="ad1b83d07c4e05a86e054fbaa32e50468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b83d07c4e05a86e054fbaa32e50468">&#9670;&nbsp;</a></span>NumberOfMessageSeries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int BufferedTransformation::NumberOfMessageSeries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the number of messages in a series. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of messages in this series </dd></dl>

<p>Reimplemented in <a class="el" href="class_message_queue.html#a2366404f56eeb93ac97d44e5abb7e940">MessageQueue</a>.</p>

</div>
</div>
<a id="aced989ed6c34a7e91c725df5daffcf57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced989ed6c34a7e91c725df5daffcf57">&#9670;&nbsp;</a></span>NumberOfMessagesInThisSeries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int BufferedTransformation::NumberOfMessagesInThisSeries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the number of messages in a series. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of messages in this series </dd></dl>

<p>Reimplemented in <a class="el" href="class_message_queue.html#abc4b9d535126eff81e67ef29074a3887">MessageQueue</a>.</p>

</div>
</div>
<a id="ae0d30db7e9ac411f51e33b56bb052b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d30db7e9ac411f51e33b56bb052b5b">&#9670;&nbsp;</a></span>Peek() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::Peek </td>
          <td>(</td>
          <td class="paramtype">byte &amp;&#160;</td>
          <td class="paramname"><em>outByte</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek a 8-bit byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outByte</td><td>the 8-bit value to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read during the call.</dd></dl>
<p>Peek does not remove bytes from the object. Use the return value of <a class="el" href="class_buffered_transformation.html#a9e1ad913c8fe697d269f408a7d5928fc" title="Retrieve a 8-bit byte. ">Get()</a> to detect short reads. </p>

<p>Reimplemented in <a class="el" href="class_byte_queue_1_1_walker.html#a7957014044dfccad88074959455e36c1">ByteQueue::Walker</a>, and <a class="el" href="class_byte_queue.html#a41550f99083f9eff6a30ac2ad604f3ce">ByteQueue</a>.</p>

</div>
</div>
<a id="a796d9889c070ea85d9df262806579314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796d9889c070ea85d9df262806579314">&#9670;&nbsp;</a></span>Peek() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::Peek </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>outString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>peekMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek a block of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outString</td><td>a block of bytes </td></tr>
    <tr><td class="paramname">peekMax</td><td>the number of bytes to Peek </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read during the call.</dd></dl>
<p>Peek does not remove bytes from the object. Use the return value of <a class="el" href="class_buffered_transformation.html#a9e1ad913c8fe697d269f408a7d5928fc" title="Retrieve a 8-bit byte. ">Get()</a> to detect short reads. </p>

<p>Reimplemented in <a class="el" href="class_byte_queue_1_1_walker.html#a0fbdd794afcbf561526a44a9f8698301">ByteQueue::Walker</a>, and <a class="el" href="class_byte_queue.html#a6e15989ef3b2f97963df4d3b471bfdc6">ByteQueue</a>.</p>

</div>
</div>
<a id="a57f6cc9f7a38884cde234f3367df62b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f6cc9f7a38884cde234f3367df62b6">&#9670;&nbsp;</a></span>PeekWord16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::PeekWord16 </td>
          <td>(</td>
          <td class="paramtype">word16 &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peek a 16-bit word. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 16-bit value to be retrieved </td></tr>
    <tr><td class="paramname">order</td><td>the ByteOrder of the value to be processed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes consumed during the call.</dd></dl>
<p>Peek does not consume bytes in the stream. Use the return value of <a class="el" href="class_buffered_transformation.html#a1ac50bcb2d279c3c6aef6858dab3eeb7" title="Retrieve a 16-bit word. ">GetWord16()</a> to detect short reads. </p>

</div>
</div>
<a id="a62bfe64be6bc1b65d84e3408e510b25a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62bfe64be6bc1b65d84e3408e510b25a">&#9670;&nbsp;</a></span>PeekWord32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::PeekWord32 </td>
          <td>(</td>
          <td class="paramtype">word32 &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peek a 32-bit word. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 32-bit value to be retrieved </td></tr>
    <tr><td class="paramname">order</td><td>the ByteOrder of the value to be processed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes consumed during the call.</dd></dl>
<p>Peek does not consume bytes in the stream. Use the return value of <a class="el" href="class_buffered_transformation.html#a1ac50bcb2d279c3c6aef6858dab3eeb7" title="Retrieve a 16-bit word. ">GetWord16()</a> to detect short reads. </p>

</div>
</div>
<a id="ae70658b0d271f8e114ac6c3cc9774ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70658b0d271f8e114ac6c3cc9774ede">&#9670;&nbsp;</a></span>Put() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::Put </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>inByte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input a byte for processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inByte</td><td>the 8-bit byte (octet) to be processed. </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that remain in the block (i.e., bytes not processed)</dd></dl>
<p><code>Put(byte)</code> calls <code>Put(byte*, size_t)</code>. </p>

</div>
</div>
<a id="a44e935e60d3877975a7c82c6353d65c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e935e60d3877975a7c82c6353d65c9">&#9670;&nbsp;</a></span>Put() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::Put </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>inString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input a byte buffer for processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inString</td><td>the byte buffer to process </td></tr>
    <tr><td class="paramname">length</td><td>the size of the string, in bytes </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that remain in the block (i.e., bytes not processed)</dd></dl>
<p>Internally, <a class="el" href="class_buffered_transformation.html#ae70658b0d271f8e114ac6c3cc9774ede" title="Input a byte for processing. ">Put()</a> calls <a class="el" href="class_buffered_transformation.html#ad396dcb42260f23125a35ec0e5d17d55" title="Input multiple bytes for processing. ">Put2()</a>. </p>

</div>
</div>
<a id="ad396dcb42260f23125a35ec0e5d17d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad396dcb42260f23125a35ec0e5d17d55">&#9670;&nbsp;</a></span>Put2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t BufferedTransformation::Put2 </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>inString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>messageEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input multiple bytes for processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inString</td><td>the byte buffer to process </td></tr>
    <tr><td class="paramname">length</td><td>the size of the string, in bytes </td></tr>
    <tr><td class="paramname">messageEnd</td><td>means how many filters to signal <a class="el" href="class_buffered_transformation.html#a20ae0ef2e4ff338b43849e541e9b940f" title="Signals the end of messages to the object. ">MessageEnd()</a> to, including this one </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input</td></tr>
  </table>
  </dd>
</dl>
<p>Derived classes must implement <a class="el" href="class_buffered_transformation.html#ad396dcb42260f23125a35ec0e5d17d55" title="Input multiple bytes for processing. ">Put2()</a>. </p>

<p>Implemented in <a class="el" href="class_filter_tester.html#a5e5686836378a9fdadd9aa51f0405802">FilterTester</a>, <a class="el" href="class_array_xor_sink.html#a20637eac89903059461b27d621dcc339">ArrayXorSink</a>, <a class="el" href="class_array_sink.html#ad3459c605b5eb52fa24efcb4dc35d29d">ArraySink</a>, <a class="el" href="class_random_number_sink.html#aed57770519427841e3aac3abc251bc64">RandomNumberSink</a>, <a class="el" href="class_string_sink_template.html#a167e78771671daf216f190bd4fe13c9b">StringSinkTemplate&lt; T &gt;</a>, <a class="el" href="class_output_proxy.html#ade676bde70daea1949bab94e72d93b18">OutputProxy</a>, <a class="el" href="class_redirector.html#a51620dc9565b323de2b55d3a85e830a1">Redirector</a>, <a class="el" href="class_p_k___default_decryption_filter.html#a997075864fd04d41c42a8e8d8361623f">PK_DefaultDecryptionFilter</a>, <a class="el" href="class_p_k___default_encryption_filter.html#a1e82dd1a02eed0bcf6218829a729904c">PK_DefaultEncryptionFilter</a>, <a class="el" href="class_signer_filter.html#acfba1ed693cebff62db4d2bde7c011e5">SignerFilter</a>, <a class="el" href="class_hash_filter.html#a7dde1304b794c488f43cb60f8bbf7b66">HashFilter</a>, <a class="el" href="class_filter_with_input_queue.html#a91c11ca74a8ba2350da6ad6ca8d721a0">FilterWithInputQueue</a>, <a class="el" href="class_bit_bucket.html#a4eb69986b7bc8391f757c8dd7a84eda6">BitBucket</a>, <a class="el" href="class_filter_with_buffered_input.html#a9885841f5ecee1403b57c5b1fc28a928">FilterWithBufferedInput</a>, <a class="el" href="class_meter_filter.html#a7d59d4e7f674b5ba6a54e8e241cf9148">MeterFilter</a>, <a class="el" href="class_multichannel.html#a5e8ff874d5703311a9947cf086170fa6">Multichannel&lt; Filter &gt;</a>, <a class="el" href="class_multichannel.html#a5e8ff874d5703311a9947cf086170fa6">Multichannel&lt; Sink &gt;</a>, <a class="el" href="class_padding_remover.html#aae803b9a474a16cc10ae3ab66630b299">PaddingRemover</a>, <a class="el" href="class_file_sink.html#a7d9f9457b3a9d7db252e8ba75487020a">FileSink</a>, <a class="el" href="class_input_rejecting.html#acfac9e0290dc999234df2e595c367926">InputRejecting&lt; BufferedTransformation &gt;</a>, <a class="el" href="class_input_rejecting.html#acfac9e0290dc999234df2e595c367926">InputRejecting&lt; Filter &gt;</a>, <a class="el" href="class_grouper.html#a21cb0add26fcf2607329927714f4e3bb">Grouper</a>, <a class="el" href="class_information_dispersal.html#a0dd51a1bdc83cea84cd72218730f4744">InformationDispersal</a>, <a class="el" href="class_deflator.html#ab3ba26f52807a9b5d4af6948d56cd4a9">Deflator</a>, <a class="el" href="class_inflator.html#aeb7d602a16d9263b25b96030aa5583ec">Inflator</a>, <a class="el" href="class_maurer_randomness_test.html#ae2629df58de48eafc8b8d9f0b060ff98">MaurerRandomnessTest</a>, <a class="el" href="class_base_n___decoder.html#a56c46bd846fca139874903d26df4385f">BaseN_Decoder</a>, <a class="el" href="class_secret_sharing.html#a26acaced75c630173f17ab29f615d409">SecretSharing</a>, <a class="el" href="class_base_n___encoder.html#adb9ab1b4d48de6c26b04d4691be2f0f0">BaseN_Encoder</a>, <a class="el" href="class_byte_queue.html#a684942d5641278a78e7c237a5bd4c69d">ByteQueue</a>, and <a class="el" href="class_message_queue.html#a3ca42e60e7de1cfada145609cb3eb5e9">MessageQueue</a>.</p>

</div>
</div>
<a id="aa10b7e626f5af900a4d12f6e5d125891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10b7e626f5af900a4d12f6e5d125891">&#9670;&nbsp;</a></span>PutMessageEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::PutMessageEnd </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>inString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propagation</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input multiple bytes for processing and signal the end of a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inString</td><td>the byte buffer to process </td></tr>
    <tr><td class="paramname">length</td><td>the size of the string, in bytes </td></tr>
    <tr><td class="paramname">propagation</td><td>the number of attached transformations the <a class="el" href="class_buffered_transformation.html#a20ae0ef2e4ff338b43849e541e9b940f" title="Signals the end of messages to the object. ">MessageEnd()</a> signal should be passed </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that remain in the block (i.e., bytes not processed)</dd></dl>
<p>Internally, <a class="el" href="class_buffered_transformation.html#aa10b7e626f5af900a4d12f6e5d125891" title="Input multiple bytes for processing and signal the end of a message. ">PutMessageEnd()</a> calls <a class="el" href="class_buffered_transformation.html#ad396dcb42260f23125a35ec0e5d17d55" title="Input multiple bytes for processing. ">Put2()</a> with a modified propagation to ensure all attached transformations finish processing the message.</p>
<p>propagation count includes this object. Setting propagation to <code>1</code> means this object only. Setting propagation to <code>-1</code> means unlimited propagation. </p>

</div>
</div>
<a id="ae15df84a7b67c25dfe2ce0ef5a74123c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15df84a7b67c25dfe2ce0ef5a74123c">&#9670;&nbsp;</a></span>PutModifiable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::PutModifiable </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>inString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input multiple bytes that may be modified by callee. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inString</td><td>the byte buffer to process </td></tr>
    <tr><td class="paramname">length</td><td>the size of the string, in bytes </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 indicates all bytes were processed during the call. Non-0 indicates the number of bytes that were <em>not</em> processed </dd></dl>

</div>
</div>
<a id="a770bf11f26d4dec66423a7dc2d36843d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770bf11f26d4dec66423a7dc2d36843d">&#9670;&nbsp;</a></span>PutModifiable2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t BufferedTransformation::PutModifiable2 </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>inString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>messageEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input multiple bytes that may be modified by callee. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inString</td><td>the byte buffer to process. </td></tr>
    <tr><td class="paramname">length</td><td>the size of the string, in bytes. </td></tr>
    <tr><td class="paramname">messageEnd</td><td>means how many filters to signal <a class="el" href="class_buffered_transformation.html#a20ae0ef2e4ff338b43849e541e9b940f" title="Signals the end of messages to the object. ">MessageEnd()</a> to, including this one. </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input.</td></tr>
  </table>
  </dd>
</dl>
<p>Internally, <a class="el" href="class_buffered_transformation.html#a770bf11f26d4dec66423a7dc2d36843d" title="Input multiple bytes that may be modified by callee. ">PutModifiable2()</a> calls <a class="el" href="class_buffered_transformation.html#ad396dcb42260f23125a35ec0e5d17d55" title="Input multiple bytes for processing. ">Put2()</a>. </p>

<p>Reimplemented in <a class="el" href="class_output_proxy.html#a0b7247fde67865b260d55763e14fdfa5">OutputProxy</a>, <a class="el" href="class_filter_with_buffered_input.html#abc7a44af560a17d30a48651683e18e6e">FilterWithBufferedInput</a>, <a class="el" href="class_multichannel.html#ae5a9ac9bf82eb7f4eadc7c38fd604216">Multichannel&lt; Filter &gt;</a>, <a class="el" href="class_multichannel.html#ae5a9ac9bf82eb7f4eadc7c38fd604216">Multichannel&lt; Sink &gt;</a>, and <a class="el" href="class_meter_filter.html#a03c8af7442aa844e83e4c45397373f14">MeterFilter</a>.</p>

</div>
</div>
<a id="a92c60616792d7bce5cd41eaffbd1c3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c60616792d7bce5cd41eaffbd1c3cc">&#9670;&nbsp;</a></span>PutWord16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::PutWord16 </td>
          <td>(</td>
          <td class="paramtype">word16&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Input a 16-bit word for processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 16-bit value to be processed </td></tr>
    <tr><td class="paramname">order</td><td>the ByteOrder of the value to be processed. </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that remain in the block (i.e., bytes not processed) </dd></dl>

</div>
</div>
<a id="affcc574867d51528afe3c96721ded075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcc574867d51528afe3c96721ded075">&#9670;&nbsp;</a></span>PutWord32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::PutWord32 </td>
          <td>(</td>
          <td class="paramtype">word32&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142b">ByteOrder</a>&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="cryptlib_8h.html#aaeb92d42f5a6e27b8ba19f18d69d142baf0c3bb6c718cc7ff0bffef4e8f178c57">BIG_ENDIAN_ORDER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Input a 32-bit word for processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 32-bit value to be processed. </td></tr>
    <tr><td class="paramname">order</td><td>the ByteOrder of the value to be processed. </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that remain in the block (i.e., bytes not processed) </dd></dl>

</div>
</div>
<a id="a25686ebe4c3ba26e7eeaae1dcd4d4215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25686ebe4c3ba26e7eeaae1dcd4d4215">&#9670;&nbsp;</a></span>Ref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_buffered_transformation.html">BufferedTransformation</a>&amp; BufferedTransformation::Ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a reference to this object. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object</dd></dl>
<p>Useful for passing a temporary object to a function that takes a non-const reference </p>

</div>
</div>
<a id="ae77dc2fddb3ff142effb00eff3217581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77dc2fddb3ff142effb00eff3217581">&#9670;&nbsp;</a></span>SetAutoSignalPropagation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void BufferedTransformation::SetAutoSignalPropagation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propagation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set propagation of automatically generated and transferred signals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propagation</td><td>then new value</td></tr>
  </table>
  </dd>
</dl>
<p>Setting propagation to <code>0</code> means do not automatically generate signals. Setting propagation to <code>-1</code> means unlimited propagation. </p>

<p>Reimplemented in <a class="el" href="class_source_template.html#af7f891477e9fcea66954f848b86de0a2">SourceTemplate&lt; T &gt;</a>, <a class="el" href="class_source_template.html#af7f891477e9fcea66954f848b86de0a2">SourceTemplate&lt; FileStore &gt;</a>, <a class="el" href="class_source_template.html#af7f891477e9fcea66954f848b86de0a2">SourceTemplate&lt; RandomNumberStore &gt;</a>, and <a class="el" href="class_source_template.html#af7f891477e9fcea66954f848b86de0a2">SourceTemplate&lt; StringStore &gt;</a>.</p>

</div>
</div>
<a id="aeeb151c318a472c5f1cf41617f3414a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb151c318a472c5f1cf41617f3414a5">&#9670;&nbsp;</a></span>SetRetrievalChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BufferedTransformation::SetRetrievalChannel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the default retrieval channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to signal the end of a series of messages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function may not be implemented in all objects that should support it. </dd></dl>

</div>
</div>
<a id="a0c25529ded99db20ad35ccef3f7234e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c25529ded99db20ad35ccef3f7234e6">&#9670;&nbsp;</a></span>Skip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lword BufferedTransformation::Skip </td>
          <td>(</td>
          <td class="paramtype">lword&#160;</td>
          <td class="paramname"><em>skipMax</em> = <code>LWORD_MAX</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discard skipMax bytes from the output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skipMax</td><td>the number of bytes to discard</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_buffered_transformation.html#a0c25529ded99db20ad35ccef3f7234e6" title="Discard skipMax bytes from the output buffer. ">Skip()</a> discards bytes from the output buffer, which is the <a class="el" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="Returns the object immediately attached to this object. ">AttachedTransformation()</a>, if present. The function always returns the parameter <code>skipMax</code>.</p>
<p>If you want to skip bytes from a <a class="el" href="class_source.html" title="Implementation of BufferedTransformation&#39;s attachment interface. ">Source</a>, then perform the following. </p><pre>
    <a class="el" href="class_string_source.html">StringSource</a> ss(str, false, new <a class="el" href="class_redirector.html" title="Redirect input to another BufferedTransformation without owning it. ">Redirector(TheBitBucket())</a>);
    ss.Pump(10);    // Skip 10 bytes from <a class="el" href="class_source.html" title="Implementation of BufferedTransformation&#39;s attachment interface. ">Source</a>
    ss.Detach(new FilterChain(...));
    ss.PumpAll();
</pre> 
<p>Reimplemented in <a class="el" href="class_file_store.html#a224d31ea858a3c890fec604a030db7cf">FileStore</a>.</p>

</div>
</div>
<a id="ace560f14489f478bb4cd17c41905774e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace560f14489f478bb4cd17c41905774e">&#9670;&nbsp;</a></span>SkipMessages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int BufferedTransformation::SkipMessages </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em> = <code>UINT_MAX</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip a number of meessages. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if the requested number of messages was skipped, non-0 otherwise</dd></dl>
<p><a class="el" href="class_buffered_transformation.html#ace560f14489f478bb4cd17c41905774e" title="Skip a number of meessages. ">SkipMessages()</a> skips count number of messages. If there is an <a class="el" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="Returns the object immediately attached to this object. ">AttachedTransformation()</a> then <a class="el" href="class_buffered_transformation.html#ace560f14489f478bb4cd17c41905774e" title="Skip a number of meessages. ">SkipMessages()</a> is called on the attached transformation. If there is no attached transformation, then count number of messages are sent to <a class="el" href="cryptlib_8h.html#ab4a4f9334f5cde9cd180904b76664bbe" title="An input discarding BufferedTransformation. ">TheBitBucket()</a> using <a class="el" href="class_buffered_transformation.html#a0446d21781676a6f9c64d0b7a727d314" title="Transfer messages from this object to another BufferedTransformation. ">TransferMessagesTo()</a>. </p>

</div>
</div>
<a id="ab4e77f500d62436a8bd1597e6b6443a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e77f500d62436a8bd1597e6b6443a1">&#9670;&nbsp;</a></span>TotalBytesRetrievable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lword BufferedTransformation::TotalBytesRetrievable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the number of bytes ready for retrieval. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes ready for retrieval </dd></dl>

<p>Reimplemented in <a class="el" href="class_message_queue.html#ad42da27546fd65f68cecb4b6bab7fb5c">MessageQueue</a>.</p>

</div>
</div>
<a id="a84c3629cdd9be90695c9701c1b8e24a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c3629cdd9be90695c9701c1b8e24a2">&#9670;&nbsp;</a></span>TransferAllTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BufferedTransformation::TransferAllTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em> = <code><a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer all bytes from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>the destination <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a> </td></tr>
    <tr><td class="paramname">channel</td><td>the channel on which the transfer should occur</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_buffered_transformation.html#a1a70058989762156c376d7ffa5cb303e" title="Transfer messages from this object to another BufferedTransformation. ">TransferMessagesTo2()</a> removes messages from this object and moves them to the destination. Internally <a class="el" href="class_buffered_transformation.html#a84c3629cdd9be90695c9701c1b8e24a2" title="Transfer all bytes from this object to another BufferedTransformation. ">TransferAllTo()</a> calls <a class="el" href="class_buffered_transformation.html#a3e47718aa65674256e1b069ec8e706b7" title="Transfer all bytes from this object to another BufferedTransformation. ">TransferAllTo2()</a>. </p>

</div>
</div>
<a id="a3e47718aa65674256e1b069ec8e706b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e47718aa65674256e1b069ec8e706b7">&#9670;&nbsp;</a></span>TransferAllTo2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::TransferAllTo2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em> = <code><a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer all bytes from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>the destination <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a> </td></tr>
    <tr><td class="paramname">channel</td><td>the channel on which the transfer should occur </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that remain in the current transfer block (i.e., bytes not transferred)</dd></dl>
<p><a class="el" href="class_buffered_transformation.html#a1a70058989762156c376d7ffa5cb303e" title="Transfer messages from this object to another BufferedTransformation. ">TransferMessagesTo2()</a> removes messages from this object and moves them to the destination. </p>

</div>
</div>
<a id="a0446d21781676a6f9c64d0b7a727d314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0446d21781676a6f9c64d0b7a727d314">&#9670;&nbsp;</a></span>TransferMessagesTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int BufferedTransformation::TransferMessagesTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em> = <code>UINT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em> = <code><a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer messages from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>the destination <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a> </td></tr>
    <tr><td class="paramname">count</td><td>the number of messages to transfer </td></tr>
    <tr><td class="paramname">channel</td><td>the channel on which the transfer should occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that remain in the current transfer block (i.e., bytes not transferred)</dd></dl>
<p><a class="el" href="class_buffered_transformation.html#a1a70058989762156c376d7ffa5cb303e" title="Transfer messages from this object to another BufferedTransformation. ">TransferMessagesTo2()</a> removes messages from this object and moves them to the destination. If all bytes are not transferred for a message, then processing stops and the number of remaining bytes is returned. <a class="el" href="class_buffered_transformation.html#a0446d21781676a6f9c64d0b7a727d314" title="Transfer messages from this object to another BufferedTransformation. ">TransferMessagesTo()</a> does not proceed to the next message.</p>
<p>A return value of 0 indicates all messages were successfully transferred. </p>

</div>
</div>
<a id="a1a70058989762156c376d7ffa5cb303e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a70058989762156c376d7ffa5cb303e">&#9670;&nbsp;</a></span>TransferMessagesTo2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t BufferedTransformation::TransferMessagesTo2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>messageCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em> = <code><a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer messages from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>the destination <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a> </td></tr>
    <tr><td class="paramname">messageCount</td><td>the number of messages to transfer </td></tr>
    <tr><td class="paramname">channel</td><td>the channel on which the transfer should occur </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that remain in the current transfer block (i.e., bytes not transferred)</dd></dl>
<p><a class="el" href="class_buffered_transformation.html#a1a70058989762156c376d7ffa5cb303e" title="Transfer messages from this object to another BufferedTransformation. ">TransferMessagesTo2()</a> removes messages from this object and moves them to the destination.</p>
<p>messageCount is an <em>IN</em> and <em>OUT</em> parameter. When the call is made, messageCount is the the number of messages requested to be transferred. When the call returns, messageCount is the number of messages actually transferred. </p>

</div>
</div>
<a id="ac31ac5d2da7897fb097086496b85e6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31ac5d2da7897fb097086496b85e6f5">&#9670;&nbsp;</a></span>TransferTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lword BufferedTransformation::TransferTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lword&#160;</td>
          <td class="paramname"><em>transferMax</em> = <code>LWORD_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em> = <code><a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move transferMax bytes of the buffered output to target as input </p>
<p>Transfer bytes from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>the destination <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a> </td></tr>
    <tr><td class="paramname">transferMax</td><td>the number of bytes to transfer </td></tr>
    <tr><td class="paramname">channel</td><td>the channel on which the transfer should occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes transferred during the call.</dd></dl>
<p>TransferTo removes bytes from this object and moves them to the destination.</p>
<p>The function always returns transferMax. If an accurate count is needed, then use <a class="el" href="class_buffered_transformation.html#a27ac15af3ef43c5ad1e9db5812025fcd" title="Transfer bytes from this object to another BufferedTransformation. ">TransferTo2()</a>. </p>

</div>
</div>
<a id="a27ac15af3ef43c5ad1e9db5812025fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ac15af3ef43c5ad1e9db5812025fcd">&#9670;&nbsp;</a></span>TransferTo2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t BufferedTransformation::TransferTo2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_buffered_transformation.html">BufferedTransformation</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lword &amp;&#160;</td>
          <td class="paramname"><em>byteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em> = <code><a class="el" href="cryptlib_8h.html#a6f1917f54ea8c2a45de6e08c5087c8de">DEFAULT_CHANNEL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer bytes from this object to another <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>the destination <a class="el" href="class_buffered_transformation.html" title="Interface for buffered transformations. ">BufferedTransformation</a> </td></tr>
    <tr><td class="paramname">byteCount</td><td>the number of bytes to transfer </td></tr>
    <tr><td class="paramname">channel</td><td>the channel on which the transfer should occur </td></tr>
    <tr><td class="paramname">blocking</td><td>specifies whether the object should block when processing input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that remain in the transfer block (i.e., bytes not transferred)</dd></dl>
<p><a class="el" href="class_buffered_transformation.html#ac31ac5d2da7897fb097086496b85e6f5" title="move transferMax bytes of the buffered output to target as input ">TransferTo()</a> removes bytes from this object and moves them to the destination. Transfer begins at the index position in the current stream, and not from an absolute position in the stream.</p>
<p>byteCount is an <em>IN</em> and <em>OUT</em> parameter. When the call is made, byteCount is the requested size of the transfer. When the call returns, byteCount is the number of bytes that were transferred. </p>

<p>Implemented in <a class="el" href="class_null_store.html#ac56b49281ee6f702ed4d23692e6d5528">NullStore</a>, <a class="el" href="class_random_number_store.html#aa7c2e0b12f4c8909f9424bbc77eb85dd">RandomNumberStore</a>, <a class="el" href="class_string_store.html#acca5c45df0db23ac71fb363d7005743b">StringStore</a>, <a class="el" href="class_sink.html#a3f00dceb03f4eae824a42e285e2f6972">Sink</a>, <a class="el" href="class_b_e_r_general_decoder.html#a52f64e5904cbdddea92dfcff67d4cc7a">BERGeneralDecoder</a>, <a class="el" href="class_byte_queue_1_1_walker.html#a47dd1577232b3d6ebd311b5c6d8a1f43">ByteQueue::Walker</a>, <a class="el" href="class_filter.html#ab24c6c52bb6185c25ee6efcced36dbd0">Filter</a>, <a class="el" href="class_file_store.html#a0c42d1ff63da94c678f44df13d79468b">FileStore</a>, <a class="el" href="class_byte_queue.html#a9863db3b56bf42fb424f426afb7531cd">ByteQueue</a>, and <a class="el" href="class_message_queue.html#a7c20284d4b7c1c6bccc1e1cc8f275797">MessageQueue</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>cryptopp/<a class="el" href="cryptlib_8h_source.html">cryptlib.h</a></li>
<li>cryptopp/cryptlib.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
